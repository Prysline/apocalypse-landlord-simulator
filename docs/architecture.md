# 末日房東模擬器 - 架構設計文件

## 1. 專案概述

### 1.1 架構重構目標
本專案旨在將單體架構的末日房東模擬器重構為模組化系統，實現以下核心目標：

- **功能穩定性維持**：確保重構過程不影響現有遊戲功能
- **程式碼可維護性提升**：透過模組化降低耦合度，提高內聚性
- **系統擴展性增強**：建立資料驅動架構，支援快速功能迭代
- **開發效率優化**：分離關注點，允許並行開發不同模組

### 1.2 技術決策原則
重構過程遵循以下技術原則：

1. **漸進式遷移**：採用雙軌並行策略，避免大爆炸式變更
2. **向後相容**：新系統必須完全相容舊系統功能
3. **資料驅動**：將硬編碼邏輯轉換為可配置的資料結構
4. **模組化設計**：遵循單一職責和開閉原則
5. **零部署中斷**：確保 GitHub Pages 部署的連續性

## 2. 架構設計

### 2.1 整體架構概覽

```
┌─────────────────────────────────────────────────────────┐
│                    使用者介面層                         │
│  ┌─────────────────┐  ┌─────────────────┐              │
│  │   原始UI系統    │  │   新UI管理器    │              │
│  └─────────────────┘  └─────────────────┘              │
└─────────────┬───────────────────┬─────────────────────────┘
              │                   │
┌─────────────┴─────────────────┐ │
│          橋接層               │ │
│  ┌─────────────────────────┐  │ │
│  │     GameBridge          │  │ │
│  │  (適配器 + 外觀模式)    │  │ │
│  └─────────────────────────┘  │ │
└─────────────┬─────────────────┘ │
              │                   │
┌─────────────┴─────────────────┐ ┌┴─────────────────────────────┐
│        舊系統核心             │ │         新系統核心           │
│  ┌─────────────────────────┐  │ │  ┌─────────────────────────┐ │
│  │      GameState          │  │ │  │     DataManager         │ │
│  │   (原始遊戲狀態)        │  │ │  │   (資料管理核心)        │ │
│  └─────────────────────────┘  │ │  └─────────────────────────┘ │
│  ┌─────────────────────────┐  │ │  ┌─────────────────────────┐ │
│  │   原始遊戲邏輯函數      │  │ │  │     RuleEngine          │ │
│  │                         │  │ │  │   (規則執行引擎)        │ │
│  └─────────────────────────┘  │ │  └─────────────────────────┘ │
└───────────────────────────────┘ └─────────────────────────────┘
              │                                   │
┌─────────────┴─────────────────┐ ┌───────────────┴───────────────┐
│        資料存儲層             │ │         配置資料層             │
│  ┌─────────────────────────┐  │ │  ┌─────────────────────────┐  │
│  │   硬編碼常數與陣列      │  │ │  │     JSON配置檔案        │  │
│  │                         │  │ │  │  - tenants.json         │  │
│  └─────────────────────────┘  │ │  │  - skills.json          │  │
└───────────────────────────────┘ │  │  - events.json          │  │
                                  │  │  - rules.json           │  │
                                  │  └─────────────────────────┘  │
                                  └─────────────────────────────┘
```

### 2.2 核心組件架構

#### 2.2.1 DataManager（資料管理核心）

**職責定義**：
- 統一資料載入與快取機制
- 資料驗證與一致性檢查
- 支援熱重載（開發階段）
- 提供資料存取的抽象層

**設計模式應用**：
- **單例模式**：確保全域唯一的資料管理器實例
- **快取模式**：減少重複的檔案載入操作
- **策略模式**：支援多種資料來源（檔案、記憶體、遠端）

**關鍵技術決策**：
```javascript
// 非同步載入 + 快取策略
async loadData(dataType, forceReload = false) {
    // 快取檢查 → 載入狀態檢查 → 實際載入 → 驗證 → 快取存儲
}
```

**錯誤處理策略**：
- 載入失敗時自動回退到預設資料
- 提供詳細的錯誤資訊供除錯使用
- 支援部分載入失敗的優雅降級

#### 2.2.2 RuleEngine（規則執行引擎）

**設計哲學**：
將遊戲邏輯從程序性程式碼轉換為聲明式規則配置，實現邏輯與資料的完全分離。

**核心架構**：
```javascript
規則定義 = {
    條件檢查器: Map<string, Function>,
    效果執行器: Map<string, Function>,
    規則註冊表: Map<string, Rule>
}
```

**擴展性設計**：
- **開閉原則**：可添加新的條件檢查器和效果執行器
- **組合模式**：支援複雜條件的嵌套組合
- **命令模式**：每個效果都是可撤銷的命令物件

#### 2.2.3 GameBridge（橋接系統）

**架構模式選擇**：
採用**適配器模式**和**外觀模式**的組合，原因如下：

1. **適配器模式**：解決新舊系統介面不相容問題
2. **外觀模式**：為複雜的子系統交互提供簡化介面
3. **代理模式**：攔截關鍵操作，選擇性啟用新功能

**漸進遷移策略**：
```javascript
function 遊戲功能() {
    if (新系統可用) {
        return 新系統實作();
    } else {
        return 原始系統實作();
    }
}
```

### 2.3 資料層架構

#### 2.3.1 JSON配置檔案結構

**設計原則**：
- **標準化**：統一的結構模式和命名規範
- **可驗證性**：每種資料類型都有對應的驗證器
- **可擴展性**：支援向前相容的欄位擴展
- **可讀性**：人類可讀的結構化資料

**檔案職責分工**：
- `tenants.json`：租客屬性、技能關聯、解鎖條件
- `skills.json`：技能定義、成本效果、觸發條件
- `events.json`：事件邏輯、選擇分支、動態內容
- `rules.json`：平衡參數、機制配置、進度控制

#### 2.3.2 資料驗證機制

**驗證層級**：
1. **結構驗證**：JSON schema 符合性檢查
2. **語意驗證**：業務邏輯相關的資料一致性檢查
3. **參照完整性**：跨檔案資料參照的完整性驗證

**錯誤回復策略**：
```javascript
載入失敗 → 驗證失敗 → 部分資料缺失 → 使用預設值 → 記錄警告
```

## 3. 實作策略

### 3.1 雙軌並行實作

**核心概念**：
在單一程式碼庫中同時維護新舊兩套系統，透過橋接層管理兩者的交互，確保功能穩定的同時實現逐步遷移。

**實作階段**：
1. **基礎建設階段**：建立 DataManager 和 RuleEngine
2. **橋接整合階段**：實作 GameBridge 和資料映射
3. **功能遷移階段**：逐個模組遷移到新系統
4. **優化清理階段**：移除舊系統程式碼

### 3.2 單一HTML檔案適配

**技術挑戰**：
原始專案為單一HTML檔案，需要在不改變部署結構的前提下實現模組化。

**解決方案**：
1. **內嵌模組化**：使用 IIFE 和命名空間模式在單一檔案內建立模組邊界
2. **漸進分離**：先實現邏輯分離，後續階段再進行檔案分割
3. **向前兼容**：新架構支援未來的多檔案分離需求

**實作範例**：
```javascript
const GameCore = (() => {
    'use strict';
    
    class DataManager { /* 實作 */ }
    class RuleEngine { /* 實作 */ }
    class GameBridge { /* 實作 */ }
    
    return { DataManager, RuleEngine, GameBridge };
})();
```

### 3.3 錯誤處理與回退機制

**多層次回退策略**：
1. **資料層回退**：JSON載入失敗 → 使用內建預設資料
2. **功能層回退**：新功能失敗 → 使用原始功能實作
3. **系統層回退**：整個新系統失敗 → 完全使用原始系統

**監控與除錯**：
- 詳細的錯誤記錄和狀態追蹤
- 開發模式下的詳細除錯資訊
- 生產環境的優雅錯誤處理

## 4. 系統整合

### 4.1 新舊系統資料映射

**映射策略**：
- **結構化映射**：建立新舊資料結構的對應關係
- **語意映射**：確保功能邏輯的完全等價性
- **性能映射**：維持或改善原有的性能表現

**實作範例**：
```javascript
const tenantMapping = {
    original: () => window.tenantTypes,
    new: () => dataManager.getCachedData('tenants'),
    merger: (original, newData) => mergeTenantData(original, newData)
};
```

### 4.2 API相容性保證

**介面穩定性**：
- 所有原始函數介面保持不變
- 新功能透過擴展介面提供
- 向後相容性測試覆蓋

**函數代理實作**：
```javascript
window.originalFunction = window.gameFunction;
window.gameFunction = (...args) => {
    if (newSystemAvailable) {
        return newImplementation(...args);
    } else {
        return window.originalFunction(...args);
    }
};
```

## 5. 性能與擴展性考量

### 5.1 載入性能優化

**策略選擇**：
- **按需載入**：只載入當前需要的資料模組
- **快取機制**：避免重複載入相同資料
- **並行載入**：支援多個資料模組的並行載入

### 5.2 記憶體管理

**資源控制**：
- 合理的快取大小限制
- 及時的資源釋放機制
- 避免記憶體洩漏的設計模式

### 5.3 可擴展性設計

**水平擴展**：
- 模組化的功能劃分
- 標準化的介面定義
- 插件式的功能擴展機制

**垂直擴展**：
- 分層的架構設計
- 清晰的責任邊界
- 可配置的系統參數

## 6. 測試策略

### 6.1 相容性測試

**測試範圍**：
- 所有原始功能的行為一致性
- 新舊系統切換的無縫性
- 資料遷移的完整性

### 6.2 回歸測試

**自動化測試**：
- 核心遊戲邏輯的單元測試
- 整合測試的自動化執行
- 性能回歸測試

### 6.3 壓力測試

**負載測試**：
- 大量資料載入的性能測試
- 長時間運行的穩定性測試
- 記憶體使用的監控測試

## 7. 部署與維護

### 7.1 GitHub Pages 部署

**部署約束**：
- 靜態檔案限制
- 建構工具的限制
- 網域名稱的考量

**部署策略**：
- 開發分支和生產分支的分離
- 自動化部署流程的建立
- 回滾機制的準備

### 7.2 版本管理

**版本策略**：
- 語意化版本號的使用
- 向前相容性的維護
- 版本遷移指南的提供

### 7.3 監控與維護

**運行監控**：
- 錯誤率的監控
- 性能指標的追蹤
- 使用者體驗的測量

## 8. 未來發展規劃

### 8.1 短期目標（1-2個月）

- 完成基礎架構的實作與整合
- 實現主要遊戲系統的遷移
- 建立完整的測試覆蓋

### 8.2 中期目標（3-6個月）

- 完成所有功能的新系統遷移
- 建立現代化的開發工作流程
- 實現高級功能的擴展

### 8.3 長期目標（6個月以上）

- 完全移除舊系統程式碼
- 建立商業化產品的基礎
- 實現多平台部署能力

## 9. 風險評估與對策

### 9.1 技術風險

**風險點**：
- 新舊系統整合的複雜性
- 性能回退的可能性
- 資料一致性的挑戰

**對策**：
- 充分的測試覆蓋
- 完善的回退機制
- 漸進式的遷移策略

### 9.2 專案風險

**風險點**：
- 開發時程的延長
- 功能範圍的擴散
- 技術債務的累積

**對策**：
- 明確的里程碑設定
- 嚴格的範圍控制
- 定期的技術審查

## 10. 結論

本架構設計基於對原有系統的深入分析和對未來需求的合理預期，採用了業界成熟的設計模式和最佳實踐。透過雙軌並行的漸進式重構策略，既保證了系統的穩定性，又為未來的發展奠定了堅實的基礎。

重構的成功關鍵在於：
1. **漸進式的變更管理**
2. **完善的測試體系**
3. **清晰的架構邊界**
4. **有效的風險控制**

隨著專案的推進，本架構將持續演進和優化，以適應不斷變化的需求和技術發展。