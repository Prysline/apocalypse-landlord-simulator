<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>末日房東模擬器 - 重構版</title>
    <style>
/* === 保持原有樣式系統 === */
body {
  font-family: "Courier New", monospace;
  background-color: #2a2a2a;
  color: #e0e0e0;
  margin: 0;
  padding: 20px;
  line-height: 1.4;
}

.game-container {
  max-width: 1200px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: 1fr 300px;
  gap: 20px;
}

.main-area {
  background: #1a1a1a;
  border: 2px solid #555;
  border-radius: 8px;
  padding: 20px;
}

.sidebar {
  background: #1a1a1a;
  border: 2px solid #555;
  border-radius: 8px;
  padding: 15px;
}

.status-bar {
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
  font-size: 14px;
  flex-wrap: wrap;
}

.status-bar > div {
  padding: 4px 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  border: 1px solid #555;
}

#buildingDefenseText {
  color: #66ccff;
}

#landlordHungerText {
  color: #ffcc66;
}

.danger-status {
  color: #ff6666 !important;
  animation: pulse 2s infinite;
}

.good-status {
  color: #66ff66 !important;
}

.house-layout {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  margin-bottom: 20px;
}

.room {
  aspect-ratio: 1;
  border: 2px solid #666;
  background: #333;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
}

.room:hover {
  border-color: #888;
  background: #444;
}

.room.occupied {
  background: #2d4a2d;
  border-color: #4a7c59;
}

.room.needs-repair {
  background: #4a2d2d;
  border-color: #7c4a4a;
}

.room.infected {
  background: #4a2d2d;
  border-color: #cc4444;
  animation: pulse 2s infinite;
}

.room.reinforced {
  border-color: #4a7c9a;
  box-shadow: inset 0 0 10px rgba(74, 124, 154, 0.3);
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.tenant-info {
  font-size: 12px;
  text-align: center;
}

.resources {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  margin-bottom: 20px;
}

.resource {
  background: #333;
  padding: 10px;
  border-radius: 4px;
  text-align: center;
}

.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 20px;
}

.btn {
  background: #4a4a4a;
  border: 1px solid #666;
  color: #e0e0e0;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s;
}

.btn:hover {
  background: #555;
}

.btn:disabled {
  background: #333;
  color: #666;
  cursor: not-allowed;
}

.btn.danger {
  background: #664444;
  border-color: #aa6666;
}

.btn.success {
  background: #446644;
  border-color: #66aa66;
}

.btn.special {
  background: #666644;
  border-color: #aaaa66;
}

.log {
  background: #222;
  border: 1px solid #444;
  height: 150px;
  overflow-y: auto;
  padding: 10px;
  font-size: 12px;
}

.log-entry {
  margin-bottom: 5px;
  padding: 2px 0;
}

.log-entry.event { color: #ffcc66; }
.log-entry.rent { color: #66ff66; }
.log-entry.danger { color: #ff6666; }
.log-entry.skill { color: #66ccff; }

.tenant-list {
  margin-bottom: 15px;
}

.tenant-item {
  background: #333;
  margin: 5px 0;
  padding: 8px;
  border-radius: 4px;
  font-size: 12px;
}

.tenant-item.infected {
  background: #663333;
  border-left: 3px solid #cc4444;
}

.tenant-item.doctor { border-left: 3px solid #66cc66; }
.tenant-item.worker { border-left: 3px solid #cc8866; }
.tenant-item.soldier { border-left: 3px solid #cc6666; }
.tenant-item.farmer { border-left: 3px solid #66aa44; }

.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  z-index: 1000;
}

.modal-content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #2a2a2a;
  border: 2px solid #666;
  border-radius: 8px;
  padding: 20px;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
}

.applicant {
  background: #333;
  margin: 10px 0;
  padding: 10px;
  border-radius: 4px;
}

.applicant.infected {
  background: #663333;
  border: 2px solid #cc4444;
}

.applicant.trader {
  background: #334466;
  border: 2px solid #6688aa;
}

.modal-content p {
  margin: 6px 0;
  font-size: 13px;
  line-height: 1.5;
}

.modal-content .action-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 15px;
  justify-content: flex-end;
}

.tenant-skill-group {
  background: #2d3d2d;
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 15px;
  border-left: 4px solid #66ccff;
}

.skill-actions {
  background: #1e2e1e;
  padding: 10px;
  border-radius: 4px;
  margin: 8px 0;
  border-left: 3px solid #ffcc66;
}

.skill-actions h5 {
  margin: 0 0 5px 0;
  color: #ffcc66;
}

.skill-actions p {
  margin: 5px 0;
  font-size: 12px;
  color: #ccc;
}

/* 新增：系統狀態指示器 */
.system-status {
  position: fixed;
  top: 10px;
  right: 10px;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 11px;
  z-index: 2000;
}

.system-status.legacy { color: #ff9966; }
.system-status.hybrid { color: #66ccff; }
.system-status.new { color: #66ff66; }
    </style>
</head>
<body>
    <!-- 系統狀態指示器 -->
    <div id="systemStatus" class="system-status hybrid">
        🔄 混合系統 v1.0
    </div>

    <div class="game-container">
        <div class="main-area">
            <div class="status-bar">
                <div>第 <span id="day">1</span> 天</div>
                <div>時間: <span id="time">白天</span></div>
                <div>💰 現金: $<span id="cash">50</span></div>
                <div>🛡️ 防禦: <span id="buildingDefenseText">脆弱(0)</span></div>
                <div>🍽️ 飢餓: <span id="landlordHungerText">飽足(0)</span></div>
            </div>

            <div class="house-layout">
                <div class="room" id="room1" onclick="selectRoom(1)">
                    <div class="tenant-info" id="room1-info">空房</div>
                </div>
                <div class="room" id="room2" onclick="selectRoom(2)">
                    <div class="tenant-info" id="room2-info">空房</div>
                </div>
            </div>

            <div class="resources">
                <div class="resource">🍖 食物: <span id="food">20</span></div>
                <div class="resource">🔧 建材: <span id="materials">15</span></div>
                <div class="resource">💊 醫療: <span id="medical">10</span></div>
                <div class="resource">⛽ 燃料: <span id="fuel">8</span></div>
            </div>

            <div class="controls">
                <button class="btn success" onclick="collectRent()">收租</button>
                <button class="btn" onclick="showVisitors()">查看訪客</button>
                <button class="btn" onclick="showScavengeMenu()">派遣搜刮 (<span id="scavengeCount">0</span>/2)</button>
                <button class="btn" onclick="harvestYard()">院子採集</button>
                <button class="btn special" onclick="showSkillMenu()">使用技能</button>
                <button class="btn danger" onclick="nextDay()">下一天</button>
            </div>

            <div class="log" id="gameLog">
                <div class="log-entry">遊戲開始！你繼承了這棟老房子，末日中的倖存者們正在尋找住所...</div>
            </div>
        </div>

        <div class="sidebar">
            <h3>租客列表</h3>
            <div class="tenant-list" id="tenantList">
                <div class="tenant-item">暫無租客</div>
            </div>

            <h3>業務系統狀態</h3>
            <div class="business-system-status">
                <div><span class="status-indicator loading" id="tenantSystemStatus"></span>租客系統: <span id="tenantSystemText">載入中...</span></div>
                <div><span class="status-indicator loading" id="skillSystemStatus"></span>技能系統: <span id="skillSystemText">載入中...</span></div>
                <div><span class="status-indicator loading" id="integrationStatus"></span>系統整合: <span id="integrationText">載入中...</span></div>
            </div>

            <h3>系統資訊</h3>
            <div style="font-size: 11px;">
                <p>• 架構版本: <span id="archVersion">混合 v1.0</span></p>
                <p>• 資料系統: <span id="dataSystem">載入中...</span></p>
                <p>• 規則引擎: <span id="ruleEngine">載入中...</span></p>
                <button class="btn" onclick="showSystemInfo()" style="width: 100%; margin-top: 5px;">系統狀態</button>
            </div>

            <h3>遊戲說明</h3>
            <div style="font-size: 11px;">
                <p>• 點擊房間查看詳情</p>
                <p>• 邀請訪客租房或交易</p>
                <p>• 商人訪客提供各種交易</p>
                <p>• 租客可用資源抵付房租</p>
                <p>• 善用租客技能求生</p>
                <p>• 房東也需要食物維生</p>
                <p>• 留意商隊和流浪商人</p>
            </div>
        </div>
    </div>

    <!-- 現有的模態框HTML保持不變 -->
    <div class="modal" id="visitorModal">
        <div class="modal-content">
            <h3>今日訪客</h3>
            <div id="visitorList"></div>
            <button class="btn" onclick="closeModal()">關閉</button>
        </div>
    </div>

    <div class="modal" id="tenantModal">
        <div class="modal-content">
            <h3 id="tenantModalTitle">租客管理</h3>
            <div id="tenantModalContent"></div>
            <div id="tenantModalActions" class="action-buttons"></div>
        </div>
    </div>

    <div class="modal" id="scavengeModal">
        <div class="modal-content">
            <h3>選擇派遣人員</h3>
            <p>剩余派遣次數: <span id="remainingScavenges">2</span></p>
            <div id="availableTenants"></div>
            <button class="btn" onclick="closeModal()">取消</button>
        </div>
    </div>

    <div class="modal" id="skillModal">
        <div class="modal-content">
            <h3>租客技能</h3>
            <div id="skillList"></div>
            <button class="btn" onclick="closeModal()">關閉</button>
        </div>
    </div>

    <div class="modal" id="eventModal">
        <div class="modal-content">
            <h3 id="eventTitle">事件</h3>
            <p id="eventDescription"></p>
            <div id="eventChoices"></div>
        </div>
    </div>

    <div class="modal" id="systemInfoModal">
        <div class="modal-content">
            <h3>系統狀態資訊</h3>
            <div id="systemInfoContent"></div>
            <button class="btn" onclick="closeModal()">關閉</button>
        </div>
    </div>

<script>
// ==================== 核心架構系統 ====================

/**
 * DataManager - 資料管理核心
 * 內嵌版本，適配單一HTML檔案架構
 */
const GameCore = (() => {
    'use strict';

    // DataManager 模組
    class DataManager {
        constructor() {
            this.cache = new Map();
            this.validators = new Map();
            this.loadPromises = new Map();
            this.registerValidators();
        }

        registerValidators() {
            this.validators.set('tenants', (data) => {
                if (!Array.isArray(data)) throw new Error('租客資料必須是陣列');
                data.forEach((tenant, index) => {
                    const required = ['typeId', 'typeName', 'category', 'rent', 'skill', 'infectionRisk'];
                    required.forEach(field => {
                        if (!(field in tenant)) {
                            throw new Error(`租客 ${index}: 缺少必要欄位 ${field}`);
                        }
                    });
                });
                return true;
            });

            this.validators.set('skills', (data) => {
                if (typeof data !== 'object' || data === null) {
                    throw new Error('技能資料必須是物件');
                }
                return true;
            });
        }

        async loadData(dataType, forceReload = false) {
            if (!forceReload && this.cache.has(dataType)) {
                return this.cache.get(dataType);
            }

            if (this.loadPromises.has(dataType)) {
                return this.loadPromises.get(dataType);
            }

            const loadPromise = this._loadFromFile(dataType);
            this.loadPromises.set(dataType, loadPromise);

            try {
                const data = await loadPromise;
                this.validateData(dataType, data);
                this.cache.set(dataType, data);
                console.log(`✅ 成功載入 ${dataType} 資料`);
                return data;
            } catch (error) {
                console.warn(`⚠️ 載入 ${dataType} 失敗，使用預設資料:`, error.message);
                const defaultData = this.getDefaultData(dataType);
                this.cache.set(dataType, defaultData);
                return defaultData;
            } finally {
                this.loadPromises.delete(dataType);
            }
        }

        async _loadFromFile(dataType) {
            const filename = `data/${dataType}.json`;
            const response = await fetch(filename);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        }

        validateData(dataType, data) {
            const validator = this.validators.get(dataType);
            if (validator) {
                return validator(data);
            }
            return true;
        }

        getDefaultData(dataType) {
            const defaults = {
                tenants: window.tenantTypes || [],
                skills: {},
                events: window.events || [],
                rules: {
                    gameBalance: { landlordDailyFood: 2 },
                    mechanics: { maxScavengePerDay: 2 }
                }
            };
            return defaults[dataType] || {};
        }

        getCachedData(dataType) {
            return this.cache.get(dataType);
        }

        isDataLoaded(dataType) {
            return this.cache.has(dataType);
        }
    }

    // RuleEngine 模組
    class RuleEngine {
        constructor(gameStateRef) {
            this.gameState = gameStateRef;
            this.rules = new Map();
            this.executionHistory = [];
            this.conditionCheckers = new Map();
            this.effectExecutors = new Map();
            
            this.registerBuiltinConditions();
            this.registerBuiltinEffects();
        }

        registerBuiltinConditions() {
            this.conditionCheckers.set('hasResource', (condition, gameState) => {
                const { resource, amount } = condition;
                return (gameState.resources[resource] || 0) >= amount;
            });

            this.conditionCheckers.set('probability', (condition, gameState) => {
                return Math.random() < condition.chance;
            });
        }

        registerBuiltinEffects() {
            this.effectExecutors.set('modifyResource', (effect, gameState) => {
                const { resource, amount } = effect;
                const oldValue = gameState.resources[resource] || 0;
                gameState.resources[resource] = Math.max(0, oldValue + amount);
                return { type: 'resource', resource, amount, newValue: gameState.resources[resource] };
            });

            this.effectExecutors.set('logMessage', (effect, gameState) => {
                const { message, logType = 'event' } = effect;
                if (typeof addLog === 'function') {
                    addLog(message, logType);
                }
                return { type: 'log', message, logType };
            });
        }

        registerRule(ruleId, ruleConfig) {
            const rule = {
                id: ruleId,
                name: ruleConfig.name || ruleId,
                conditions: ruleConfig.conditions || [],
                effects: ruleConfig.effects || [],
                enabled: ruleConfig.enabled !== false
            };
            this.rules.set(ruleId, rule);
            return rule;
        }

        executeRule(ruleId, context = {}) {
            const rule = this.rules.get(ruleId);
            if (!rule || !rule.enabled) {
                return { executed: false, reason: 'rule_not_available' };
            }

            const conditionsMet = this.checkAllConditions(rule.conditions, context);
            if (!conditionsMet) {
                return { executed: false, reason: 'conditions_not_met' };
            }

            const results = [];
            rule.effects.forEach(effect => {
                try {
                    const result = this.executeEffect(effect, this.gameState);
                    results.push(result);
                } catch (error) {
                    console.error(`❌ 規則 ${ruleId} 效果執行失敗:`, error);
                    results.push({ type: 'error', error: error.message });
                }
            });

            return { executed: true, results };
        }

        checkAllConditions(conditions, context = {}) {
            if (!conditions || conditions.length === 0) return true;
            return conditions.every(condition => this.checkCondition(condition, context));
        }

        checkCondition(condition, context = {}) {
            const { type } = condition;
            const checker = this.conditionCheckers.get(type);
            if (!checker) {
                console.warn(`⚠️ 未知的條件類型: ${type}`);
                return false;
            }
            try {
                return checker(condition, { ...this.gameState, ...context });
            } catch (error) {
                console.error(`❌ 條件檢查失敗 (${type}):`, error);
                return false;
            }
        }

        executeEffect(effect, gameState) {
            const { type } = effect;
            const executor = this.effectExecutors.get(type);
            if (!executor) {
                console.warn(`⚠️ 未知的效果類型: ${type}`);
                return { type: 'unknown', originalEffect: effect };
            }
            try {
                return executor(effect, gameState);
            } catch (error) {
                console.error(`❌ 效果執行失敗 (${type}):`, error);
                return { type: 'error', error: error.message };
            }
        }
    }

    // GameBridge 模組（簡化版）
    class GameBridge {
        constructor(originalGameState) {
            this.originalGameState = originalGameState;
            this.systemStatus = { hybrid: true, version: '1.0.0' };
            this.dataManager = new DataManager();
            this.ruleEngine = new RuleEngine(originalGameState);
        }

        async initialize() {
            console.log('🌉 初始化遊戲橋接系統...');
            
            try {
                // 嘗試載入新資料
                const dataTypes = ['tenants', 'skills', 'events', 'rules'];
                for (const dataType of dataTypes) {
                    await this.dataManager.loadData(dataType);
                }
                
                this.systemStatus.dataSystemReady = true;
                console.log('✅ 橋接系統初始化完成');
                this.updateSystemStatus();
                
            } catch (error) {
                console.warn('⚠️ 橋接系統部分功能不可用:', error.message);
                this.systemStatus.dataSystemReady = false;
                this.updateSystemStatus();
            }
        }

        updateSystemStatus() {
            const statusEl = document.getElementById('systemStatus');
            const dataSystemEl = document.getElementById('dataSystem');
            const ruleEngineEl = document.getElementById('ruleEngine');

            if (statusEl) {
                statusEl.textContent = this.systemStatus.dataSystemReady ? 
                    '🟢 混合系統 - 運行中' : '🟡 混合系統 - 降級模式';
            }
            
            if (dataSystemEl) {
                dataSystemEl.textContent = this.systemStatus.dataSystemReady ? '✅ 已載入' : '❌ 使用預設';
            }
            
            if (ruleEngineEl) {
                ruleEngineEl.textContent = this.ruleEngine ? '✅ 就緒' : '❌ 不可用';
            }
        }

        getSystemInfo() {
            return {
                version: this.systemStatus.version,
                mode: this.systemStatus.dataSystemReady ? 'hybrid' : 'legacy',
                dataManager: {
                    available: !!this.dataManager,
                    loadedTypes: Array.from(this.dataManager.cache.keys())
                },
                ruleEngine: {
                    available: !!this.ruleEngine,
                    ruleCount: this.ruleEngine.rules.size
                }
            };
        }
    }

    // 模組匯出
    return {
        DataManager,
        RuleEngine, 
        GameBridge
    };
})();

// ==================== 內嵌業務系統 ====================

// 簡化版的TenantSystem (內嵌實作)
class TenantSystem {
    constructor(gameStateRef, dataManager) {
        this.gameState = gameStateRef;
        this.dataManager = dataManager;
        this.tenantStates = new Map();

        this.idCounter = 0;
    }

    // 新增：生成唯一ID的方法
    generateUniqueId() {
        const timestamp = Date.now();
        const random = Math.floor(Math.random() * 10000);
        const counter = ++this.idCounter;
        return `${timestamp}_${random}_${counter}`;
    }

    generateApplicants(count = null) {
        if (count === null) {
            count = Math.floor(Math.random() * 3) + 1;
        }

        const tenantConfigs = this.dataManager.getCachedData('tenants');
        if (!tenantConfigs) {
            console.warn('⚠️ 租客配置不可用，使用預設生成');
            return this.generateDefaultApplicants(count);
        }

        const availableTenants = this.filterAvailableTenants(tenantConfigs);
        const applicants = [];
        
        for (let i = 0; i < count; i++) {
            const config = availableTenants[Math.floor(Math.random() * availableTenants.length)];
            const applicant = this.createApplicantFromConfig(config);
            applicants.push(applicant);
        }

        console.log(`📋 生成了 ${count} 個申請者`);
        return applicants;
    }

    filterAvailableTenants(tenantConfigs) {
        return tenantConfigs.filter(config => {
            const unlockConditions = config.unlockConditions;
            if (!unlockConditions) return true;

            if (unlockConditions.day && this.gameState.day < unlockConditions.day) {
                return false;
            }

            if (unlockConditions.buildingDefense && 
                this.gameState.buildingDefense < unlockConditions.buildingDefense) {
                return false;
            }

            if (unlockConditions.totalTenants) {
                const currentTenants = this.gameState.rooms.filter(r => r.tenant).length;
                if (currentTenants < unlockConditions.totalTenants) {
                    return false;
                }
            }

            return true;
        });
    }

    createApplicantFromConfig(config) {
        return {
            ...config,
            id: this.generateUniqueId(),
            name: this.generateName(),
            infected: Math.random() < config.infectionRisk,
            personalResources: { ...config.personalResources },
            appearance: Math.random() < config.infectionRisk ? 
                this.getInfectedAppearance() : this.getNormalAppearance()
        };
    }

    hireTenant(applicant, roomId = null) {
        const room = roomId ? 
            this.gameState.rooms.find(r => r.id === roomId) :
            this.gameState.rooms.find(r => !r.tenant);

        if (!room) {
            console.warn('❌ 沒有可用房間');
            return false;
        }

        const tenant = { ...applicant };
        room.tenant = tenant;

        // 初始化租客狀態
        this.tenantStates.set(tenant.name, {
            satisfaction: 50,
            healthStatus: 'healthy',
            lastInteraction: this.gameState.day
        });

        if (!this.gameState.tenantSatisfaction) {
            this.gameState.tenantSatisfaction = {};
        }
        this.gameState.tenantSatisfaction[tenant.name] = 50;

        addLog(`新租客 ${tenant.name} 入住房間 ${room.id}`, 'rent');
        return true;
    }

    evictTenant(tenantName, reason = 'evicted') {
        const room = this.gameState.rooms.find(r => r.tenant && r.tenant.name === tenantName);
        if (!room) {
            console.warn(`❌ 找不到租客: ${tenantName}`);
            return false;
        }

        const tenant = room.tenant;
        
        // 處理離開後果
        if (reason === 'infected' && this.gameState.resources.medical >= 2) {
            this.gameState.resources.medical -= 2;
            addLog('消毒感染房間花費了 2 醫療用品', 'danger');
        }

        room.tenant = null;
        this.tenantStates.delete(tenantName);
        if (this.gameState.tenantSatisfaction) {
            delete this.gameState.tenantSatisfaction[tenantName];
        }

        addLog(`租客 ${tenantName} 離開了房間 ${room.id}`, 
               reason === 'infected' ? 'danger' : 'event');
        return true;
    }

    updateDailyTenantStates() {
        const occupiedRooms = this.gameState.rooms.filter(room => room.tenant);
        
        occupiedRooms.forEach(room => {
            const tenant = room.tenant;
            const tenantState = this.tenantStates.get(tenant.name);
            
            if (tenantState) {
                this.updateTenantSatisfaction(tenant, room, tenantState);
            }
        });
    }

    updateTenantSatisfaction(tenant, room, tenantState) {
        let satisfaction = tenantState.satisfaction;
        
        if (room.reinforced) satisfaction += 3;
        if (room.needsRepair) satisfaction -= 8;
        if (tenant.personalResources && tenant.personalResources.food < 2) satisfaction -= 10;
        
        if (this.gameState.buildingDefense >= 8) satisfaction += 4;
        if (this.gameState.buildingDefense <= 2) satisfaction -= 6;

        satisfaction = Math.max(0, Math.min(100, satisfaction));
        tenantState.satisfaction = satisfaction;
        if (this.gameState.tenantSatisfaction) {
            this.gameState.tenantSatisfaction[tenant.name] = satisfaction;
        }
    }

    generateDefaultApplicants(count) {
        const defaultTypes = ['doctor', 'worker', 'farmer', 'soldier', 'elder'];
        const applicants = [];
        
        for (let i = 0; i < count; i++) {
            const type = defaultTypes[Math.floor(Math.random() * defaultTypes.length)];
            const applicant = {
                id: Date.now() + i,
                name: this.generateName(),
                type: type,
                rent: [15, 12, 10, 18, 8][defaultTypes.indexOf(type)],
                infected: Math.random() < 0.2,
                personalResources: { food: 5, materials: 2, medical: 2, cash: 20 },
                appearance: Math.random() < 0.2 ? this.getInfectedAppearance() : this.getNormalAppearance()
            };
            applicants.push(applicant);
        }
        
        return applicants;
    }

    generateName() {
        const names = ['小明', '小華', '小李', '老王', '阿強', '小美', '阿珍', '大雄'];
        return names[Math.floor(Math.random() * names.length)];
    }

    getNormalAppearance() {
        const appearances = ['看起來精神狀態不錯', '衣著整潔，談吐得體', '眼神清澈，反應靈敏'];
        return appearances[Math.floor(Math.random() * appearances.length)];
    }

    getInfectedAppearance() {
        const appearances = ['眼神有點呆滯，反應遲鈍', '皮膚蒼白，手有輕微顫抖', '有股奇怪的味道'];
        return appearances[Math.floor(Math.random() * appearances.length)];
    }
}

// 簡化版的SkillSystem (內嵌實作)
class SkillSystem {
    constructor(gameStateRef, dataManager) {
        this.gameState = gameStateRef;
        this.dataManager = dataManager;
        this.skillRegistry = new Map();
        this.cooldownManager = new Map(); // tenantName_skillId -> expireDay
        this.usageCounter = new Map(); // tenantName_skillId -> count
        this.permanentUsage = new Map(); // tenantName_skillId -> boolean
        this.initialized = false;
    }

    async initializeSystem() {
        try {
            const skillConfigs = this.dataManager.getCachedData('skills');
            if (skillConfigs) {
                Object.entries(skillConfigs).forEach(([tenantType, skills]) => {
                    this.skillRegistry.set(tenantType, skills);
                });
            }
            this.initialized = true;
            console.log('✅ SkillSystem 初始化完成');
        } catch (error) {
            console.error('❌ SkillSystem 初始化失敗:', error);
        }
    }

    async executeSkill(tenantName, skillId) {
        if (!this.initialized) {
            console.warn('⚠️ SkillSystem 未初始化，使用原始實作');
            return { success: false, reason: 'system_not_ready' };
        }

        const tenant = this.findTenantByName(tenantName);
        if (!tenant) {
            return { success: false, reason: 'tenant_not_found' };
        }

        const skillConfig = this.getSkillConfig(tenant.typeId, skillId);
        if (!skillConfig) {
            return { success: false, reason: 'skill_not_found' };
        }

        // 檢查冷卻時間
        if (this.isOnCooldown(tenantName, skillId)) {
            const remaining = this.getCooldownRemaining(tenantName, skillId);
            return { 
                success: false, 
                reason: 'on_cooldown',
                message: `技能冷卻中，還需 ${remaining} 天`
            };
        }

        // 檢查永久性技能使用限制
        if (skillConfig.cooldown === -1 && this.isPermanentSkillUsed(tenantName, skillId)) {
            return { 
                success: false, 
                reason: 'permanent_skill_used',
                message: '此技能只能使用一次，已經使用過了'
            };
        }

        // 檢查使用次數限制
        if (skillConfig.maxUses && this.getSkillUsageCount(tenantName, skillId) >= skillConfig.maxUses) {
            return { 
                success: false, 
                reason: 'max_uses_exceeded',
                message: `技能使用次數已達上限 (${skillConfig.maxUses})`
            };
        }

        // 檢查成本
        if (!this.canAffordSkill(skillConfig)) {
            return { success: false, reason: 'insufficient_resources' };
        }

        // 支付成本
        this.paySkillCost(skillConfig, tenant);

        // 執行效果
        const effects = this.executeSkillEffects(skillConfig, tenant);

        // 設定冷卻時間
        this.setSkillCooldown(tenantName, skillId, skillConfig.cooldown || 0);

        // 記錄使用次數
        this.incrementSkillUsage(tenantName, skillId);

        // 如果是永久性技能，標記為已使用
        if (skillConfig.cooldown === -1) {
            this.markPermanentSkillUsed(tenantName, skillId);
        }

        addLog(`${tenant.name} 使用了技能：${skillConfig.name}`, 'skill');

        return {
            success: true,
            skillId: skillConfig.id,
            skillName: skillConfig.name,
            effects
        };
    }

    findTenantByName(name) {
        const room = this.gameState.rooms.find(r => r.tenant && r.tenant.name === name);
        return room ? room.tenant : null;
    }

    getSkillConfig(tenantType, skillId) {
        const tenantSkills = this.skillRegistry.get(tenantType);
        return tenantSkills ? tenantSkills.find(skill => skill.id === skillId) : null;
    }

    canAffordSkill(skillConfig) {
        const cost = skillConfig.cost || {};
        return Object.keys(cost).every(resource => {
            if (resource === 'cash') {
                return this.gameState.resources.cash >= cost[resource];
            } else {
                return (this.gameState.resources[resource] || 0) >= cost[resource];
            }
        });
    }

    paySkillCost(skillConfig, tenant) {
        const cost = skillConfig.cost || {};
        let totalPayment = 0;

        Object.keys(cost).forEach(resource => {
            const amount = cost[resource];
            
            if (resource === 'cash') {
                this.gameState.resources.cash -= amount;
                totalPayment += amount;
            } else {
                this.gameState.resources[resource] -= amount;
            }
        });

        // 支付工資給租客
        if (totalPayment > 0 && tenant && tenant.personalResources) {
            tenant.personalResources.cash = (tenant.personalResources.cash || 0) + totalPayment;
            addLog(`💰 支付 ${tenant.name} 工資 $${totalPayment}`, 'rent');
        }
    }

    executeSkillEffects(skillConfig, tenant) {
        const effects = skillConfig.effects || [];
        const results = [];

        effects.forEach(effect => {
            const result = this.executeEffect(effect, tenant);
            results.push(result);
        });

        return results;
    }

    executeEffect(effect, tenant) {
        switch (effect.type) {
            case 'modifyResource':
                const oldValue = this.gameState.resources[effect.resource] || 0;
                this.gameState.resources[effect.resource] = Math.max(0, oldValue + effect.amount);
                return {
                    type: 'resource_modified',
                    resource: effect.resource,
                    amount: effect.amount,
                    newValue: this.gameState.resources[effect.resource]
                };

            case 'healTenant':
                const infectedTenants = this.gameState.rooms
                    .filter(room => room.tenant && room.tenant.infected)
                    .map(room => room.tenant);
                
                if (infectedTenants.length > 0) {
                    const patient = infectedTenants[Math.floor(Math.random() * infectedTenants.length)];
                    patient.infected = false;
                    addLog(`${tenant.name} 治癒了 ${patient.name}`, 'skill');
                    return { type: 'tenant_healed', patient: patient.name };
                }
                return { type: 'no_target' };

            case 'repairRoom':
                const needRepairRooms = this.gameState.rooms.filter(r => r.needsRepair);
                if (needRepairRooms.length > 0) {
                    const room = needRepairRooms[0];
                    room.needsRepair = false;
                    addLog(`${tenant.name} 維修了房間 ${room.id}`, 'skill');
                    return { type: 'room_repaired', roomId: room.id };
                }
                return { type: 'no_target' };

            case 'logMessage':
                addLog(effect.message, effect.logType || 'skill');
                return { type: 'log_message', message: effect.message };

            default:
                console.warn(`⚠️ 未知的效果類型: ${effect.type}`);
                return { type: 'unknown', effect };
        }
    }

    getAvailableSkills(tenantName) {
        const tenant = this.findTenantByName(tenantName);
        if (!tenant) return [];

        const tenantSkills = this.skillRegistry.get(tenant.typeId) || [];
        
        return tenantSkills.filter(skill => {
        // 1. 過濾被動技能 - 被動技能不應在手動技能選單中顯示
        if (skill.type === 'passive') {
            return false;
        }
        
        // 2. 檢查基本可用性
        if (!this.isSkillAvailable(skill, tenant)) {
            return false;
        }
        
        // 3. 檢查特殊需求條件
        if (!this.checkSkillRequirements(skill, tenant)) {
            return false;
        }
        
        return true;
    }).map(skill => ({
        ...skill,
        cooldownRemaining: this.getCooldownRemaining(tenant.name, skill.id),
        canAfford: this.canAffordSkill(skill),
        usageCount: this.getSkillUsageCount(tenant.name, skill.id)
    }));
    }

// 新增：檢查技能特殊需求
checkSkillRequirements(skill, tenant) {
    const requirements = skill.requirements;
    if (!requirements || !requirements.conditions) return true;
    
    return requirements.conditions.every(condition => {
        switch (condition.type) {
            case 'hasTenantType':
                if (condition.value === 'infected') {
                    const infectedCount = this.gameState.rooms
                        .filter(room => room.tenant && room.tenant.infected).length;
                    return infectedCount >= (condition.count || 1);
                }
                
                if (condition.value === 'any') {
                    const tenantCount = this.gameState.rooms
                        .filter(room => room.tenant).length;
                    return tenantCount >= (condition.count || 1);
                }
                
                const typeCount = this.gameState.rooms
                    .filter(room => room.tenant && room.tenant.typeId === condition.value).length;
                return typeCount >= (condition.count || 1);
                
            case 'gameStateCheck':
                return this.checkGameStateCondition(condition);
                
            case 'hasResource':
                const { resource, amount } = condition;
                return (this.gameState.resources[resource] || 0) >= amount;
                
            default:
                return true;
        }
    });
}

// 檢查遊戲狀態條件
checkGameStateCondition(condition) {
    const { path, operator, value } = condition;
    
    switch (path) {
        case 'rooms':
            if (operator === 'hasNeedsRepair') {
                return this.gameState.rooms.some(room => room.needsRepair);
            }
            if (operator === 'hasUnReinforced') {
                return this.gameState.rooms.some(room => room.tenant && !room.reinforced);
            }
            break;
            
        default:
            const actualValue = this.getNestedValue(this.gameState, path);
            return this.compareValues(actualValue, operator, value);
    }
    
    return false;
}

// 取得冷卻剩餘時間
getCooldownRemaining(tenantName, skillId) {
    const key = `${tenantName}_${skillId}`;
    const expireDay = this.cooldownManager.get(key);
    
    if (!expireDay) return 0;
    
    const currentDay = this.gameState.day;
    return Math.max(0, expireDay - currentDay);
}

// 取得技能使用次數
getSkillUsageCount(tenantName, skillId) {
    // 這裡需要實作使用次數追蹤邏輯
    // 暫時返回0，實際需要根據遊戲狀態追蹤
    const usageKey = `${tenantName}_${skillId}_used`;
    return this.gameState[usageKey] || 0;
}

isSkillAvailable(skill, tenant) {
    // 1. 檢查冷卻時間
    if (this.getCooldownRemaining(tenant.name, skill.id) > 0) {
        return false;
    }
    
    // 2. 檢查使用次數限制
    if (skill.maxUses && this.getSkillUsageCount(tenant.name, skill.id) >= skill.maxUses) {
        return false;
    }
    
    // 3. 檢查成本
    if (!this.canAffordSkill(skill)) {
        return false;
    }
    
    // 4. 檢查租客健康狀態
    if (tenant.infected) {
        return false;
    }
    
    return true;
}
}

// ==================== 原始遊戲狀態 ====================
let gameState = {
    day: 1,
    time: "day",
    resources: { food: 20, materials: 15, medical: 10, fuel: 8, cash: 50 },
    rooms: [
        { id: 1, tenant: null, needsRepair: false, reinforced: false },
        { id: 2, tenant: null, needsRepair: false, reinforced: false }
    ],
    applicants: [],
    visitors: [],
    landlordHunger: 0,
    harvestUsed: false,
    harvestCooldown: 0,
    scavengeUsed: 0,
    maxScavengePerDay: 2,
    rentCollected: false,
    buildingDefense: 0,
    tenantSatisfaction: {},
    harmoniumBonus: 0
};

// ==================== 全域變數與初始化 ====================
let gameBridge = null;
let systemIntegrator = null;
let tenantSystem = null;
let skillSystem = null;

// 初始化系統
async function initializeGame() {
    try {
      console.log('🎮 末日房東模擬器 v1.1 啟動中...');

        gameBridge = new GameCore.GameBridge(gameState);
        await gameBridge.initialize();
        
        // 初始化業務系統
        tenantSystem = new TenantSystem(gameState, gameBridge.dataManager);
        skillSystem = new SkillSystem(gameState, gameBridge.dataManager);
        
        await skillSystem.initializeSystem();
        
        // 建立系統代理
        setupSystemProxies();
        
        // 更新系統狀態顯示
        updateSystemStatusDisplay();
        
        console.log('✅ 業務系統初始化完成');
        updateDisplay();
        
    } catch (error) {
        console.error('❌ 遊戲初始化失敗:', error);
        console.log('🔄 使用原始系統模式');
        updateDisplay();
    }
}

// 建立系統代理
function setupSystemProxies() {
    // 代理生成申請者函數
    window.originalGenerateApplicants = window.generateApplicants || function() {
        return [];
    };
    
    window.generateApplicants = function() {
        if (tenantSystem) {
            const applicants = tenantSystem.generateApplicants();
            gameState.applicants = applicants;
            return applicants;
        } else {
            return window.originalGenerateApplicants();
        }
    };

    // 代理雇用租客函數
    window.originalHireTenant = window.hireTenant || function() {
        return false;
    };
    
    window.hireTenant = function(applicantId) {
        if (tenantSystem) {
            const applicant = gameState.applicants.find(a => a.id === applicantId);
            if (applicant) {
                const success = tenantSystem.hireTenant(applicant);
                if (success) {
                    gameState.applicants = gameState.applicants.filter(a => a.id !== applicantId);
                }
                closeModal();
                updateDisplay();
                return success;
            }
            return false;
        } else {
            return window.originalHireTenant(applicantId);
        }
    };

    // 代理技能使用函數
    window.originalUseSkill = window.useSkill || function() {
        return { success: false };
    };
    
    window.useSkill = async function(tenantName, skillId) {
        if (skillSystem && skillSystem.initialized) {
            return await skillSystem.executeSkill(tenantName, skillId);
        } else {
            return window.originalUseSkill(tenantName, skillId);
        }
    };
}

// 更新系統狀態顯示
function updateSystemStatusDisplay() {
    const tenantStatusEl = document.getElementById('tenantSystemStatus');
    const tenantTextEl = document.getElementById('tenantSystemText');
    const skillStatusEl = document.getElementById('skillSystemStatus');
    const skillTextEl = document.getElementById('skillSystemText');
    const integrationStatusEl = document.getElementById('integrationStatus');
    const integrationTextEl = document.getElementById('integrationText');

    if (tenantSystem) {
        tenantStatusEl.className = 'status-indicator ready';
        tenantTextEl.textContent = '✅ 就緒';
    } else {
        tenantStatusEl.className = 'status-indicator error';
        tenantTextEl.textContent = '❌ 失敗';
    }

    if (skillSystem && skillSystem.initialized) {
        skillStatusEl.className = 'status-indicator ready';
        skillTextEl.textContent = '✅ 就緒';
    } else {
        skillStatusEl.className = 'status-indicator error';
        skillTextEl.textContent = '❌ 失敗';
    }

    if (tenantSystem && skillSystem && skillSystem.initialized) {
        integrationStatusEl.className = 'status-indicator ready';
        integrationTextEl.textContent = '✅ 完成';
    } else {
        integrationStatusEl.className = 'status-indicator loading';
        integrationTextEl.textContent = '⏳ 處理中';
    }

    // 更新基礎系統狀態
    const dataSystemEl = document.getElementById('dataSystem');
    const ruleEngineEl = document.getElementById('ruleEngine');

    if (dataSystemEl) {
        dataSystemEl.textContent = gameBridge && gameBridge.systemStatus.dataSystemReady ? '✅ 已載入' : '❌ 使用預設';
    }
    
    if (ruleEngineEl) {
        ruleEngineEl.textContent = gameBridge && gameBridge.ruleEngine ? '✅ 就緒' : '❌ 不可用';
    }
}

// ==================== 遊戲核心功能 ====================

function addLog(message, type = "") {
    const log = document.getElementById("gameLog");
    const entry = document.createElement("div");
    entry.className = `log-entry ${type}`;
    entry.textContent = `第${gameState.day}天: ${message}`;
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
}

function getDefenseStatusText(defense) {
    if (defense <= 0) return `脆弱(${defense})`;
    if (defense <= 2) return `基本(${defense})`;
    if (defense <= 5) return `穩固(${defense})`;
    if (defense <= 8) return `堅固(${defense})`;
    if (defense <= 12) return `要塞(${defense})`;
    return `銅牆鐵壁(${defense})`;
}

function getHungerStatusText(hunger) {
    if (hunger <= 0) return `飽足(${hunger})`;
    if (hunger <= 1) return `微餓(${hunger})`;
    if (hunger <= 2) return `有點餓(${hunger})`;
    if (hunger <= 3) return `飢餓(${hunger})`;
    if (hunger <= 4) return `很餓(${hunger})`;
    if (hunger <= 6) return `極度飢餓(${hunger})`;
    return `瀕臨餓死(${hunger})`;
}

function updateDisplay() {
    document.getElementById("day").textContent = gameState.day;
    document.getElementById("time").textContent = gameState.time === "day" ? "白天" : "夜晚";
    document.getElementById("cash").textContent = gameState.resources.cash;
    document.getElementById("buildingDefenseText").textContent = getDefenseStatusText(gameState.buildingDefense);
    document.getElementById("landlordHungerText").textContent = getHungerStatusText(gameState.landlordHunger);
    document.getElementById("scavengeCount").textContent = gameState.scavengeUsed;

    Object.keys(gameState.resources).forEach((resource) => {
        const element = document.getElementById(resource);
        if (element) {
            element.textContent = gameState.resources[resource];
        }
    });

    gameState.rooms.forEach((room) => {
        const roomElement = document.getElementById(`room${room.id}`);
        const infoElement = document.getElementById(`room${room.id}-info`);

        roomElement.className = "room";

        if (room.tenant) {
            roomElement.classList.add("occupied");
            if (room.tenant.infected) {
                roomElement.classList.add("infected");
            }

            const satisfaction = gameState.tenantSatisfaction[room.tenant.name] || 50;
            const satisfactionText = satisfaction >= 70 ? "😊" : satisfaction >= 40 ? "😐" : "😞";

            infoElement.innerHTML = `${room.tenant.name}<br><small>${room.tenant.skill}</small><br><small>滿意度: ${satisfaction} ${satisfactionText}</small>`;
        } else {
            infoElement.textContent = "空房";
        }

        if (room.needsRepair) {
            roomElement.classList.add("needs-repair");
            infoElement.innerHTML += '<br><small style="color:#ff6666">需要維修</small>';
        }

        if (room.reinforced) {
            roomElement.classList.add("reinforced");
            infoElement.innerHTML += '<br><small style="color:#66ccff">已加固</small>';
        }
    });

    updateTenantList();
}

function updateTenantList() {
    const tenantList = document.getElementById("tenantList");
    const tenants = gameState.rooms
        .filter((room) => room.tenant)
        .map((room) => room.tenant);

    if (tenants.length === 0) {
        tenantList.innerHTML = '<div class="tenant-item">暫無租客</div>';
    } else {
        tenantList.innerHTML = tenants
            .map((tenant) => {
                let statusText = "";
                if (tenant.infected) {
                    statusText = '<br><small style="color:#ff6666">已感染！</small>';
                } else if (tenant.onMission) {
                    statusText = '<br><small style="color:#ffaa66">執行任務中</small>';
                }

                const resourceStatus = tenant.personalResources
                    ? `<br><small style="color:#cccccc">個人: $${tenant.personalResources.cash || 0} 食物${tenant.personalResources.food || 0}</small>`
                    : "";

                const satisfaction = gameState.tenantSatisfaction[tenant.name] || 50;

                return `<div class="tenant-item ${tenant.infected ? "infected" : ""} ${tenant.typeId}">
                    ${tenant.name} (${tenant.typeName})<br>
                    <small>房租: ${tenant.rent} | ${tenant.skill}</small>
                    ${resourceStatus}
                    <small>滿意度: ${satisfaction}%</small>
                    ${statusText}
                </div>`;
            })
            .join("");
    }
}

// 基本遊戲功能 - 簡化版本，保持核心功能
function collectRent() {
    if (gameState.rentCollected) {
        alert("今天已經收過房租了！");
        return;
    }

    let totalRent = 0;
    gameState.rooms.forEach((room) => {
        if (room.tenant && !room.tenant.infected) {
            totalRent += room.tenant.rent;
        }
    });

    gameState.resources.cash += totalRent;
    gameState.rentCollected = true;
    
    if (totalRent > 0) {
        addLog(`收取房租 $${totalRent}`, "rent");
    } else {
        addLog("今日沒有房租收入", "event");
    }
    
    updateDisplay();
}

function showVisitors() {
    // 生成訪客
    generateApplicants();
    
    const modal = document.getElementById("visitorModal");
    const list = document.getElementById("visitorList");

    list.innerHTML = gameState.applicants
        .map((applicant) => {
            const infectionStatus = applicant.revealedInfection
                ? '<br><span style="color:#ff6666; font-weight:bold;">⚠ 已檢測出感染！</span>'
                : "";

            return `<div class="applicant ${applicant.revealedInfection ? "infected" : ""}">
                        <strong>${applicant.name}</strong> - ${applicant.typeName}<br>
                        <small>${applicant.description || '尋找住所的倖存者'}</small><br>
                        <small style="color: #aaa;">外觀: ${applicant.appearance}</small><br>
                        房租: ${applicant.rent}/天${infectionStatus}<br>
                        <button class="btn ${applicant.revealedInfection ? "danger" : ""}" 
                                onclick="hireTenant('${applicant.id}')" 
                                ${applicant.revealedInfection ? 'title="雇用感染者風險很高！"' : ""}>
                          雇用${applicant.revealedInfection ? " (危險)" : ""}
                        </button>
                      </div>`;
        })
        .join("");

    modal.style.display = "block";
}

function showScavengeMenu() {
    alert("派遣功能正在重構中，請稍候...");
}

function harvestYard() {
    if (gameState.harvestUsed) {
        alert("今天已經採集過院子了！");
        return;
    }

    const baseAmount = 2;
    gameState.resources.food += baseAmount;
    gameState.harvestUsed = true;
    
    addLog(`院子採集獲得 ${baseAmount} 食物`, "rent");
    updateDisplay();
}

function showSkillMenu() {
    if (!skillSystem || !skillSystem.initialized) {
        alert("技能系統正在載入中，請稍候...");
        return;
    }

    const modal = document.getElementById("skillModal");
    const skillList = document.getElementById("skillList");

    const skillsByTenant = [];

    gameState.rooms.forEach((room) => {
        if (room.tenant && !room.tenant.infected) {
            const tenant = room.tenant;
            const tenantSkills = skillSystem.getAvailableSkills(tenant.name);

            if (tenantSkills.length > 0) {
                skillsByTenant.push({
                    tenant: tenant,
                    skills: tenantSkills
                });
            }
        }
    });

    if (skillsByTenant.length === 0) {
        skillList.innerHTML = "<p>目前沒有可用的技能</p>";
    } else {
        skillList.innerHTML = skillsByTenant
            .map((tenantData) => {
                const tenant = tenantData.tenant;
                const skills = tenantData.skills;

                return `
                    <div class="tenant-skill-group">
                      <h4 style="color: #66ccff; margin: 15px 0 10px 0;">
                        ${tenant.name} (${tenant.typeName}) - 房間${getRoomIdByTenant(tenant)}
                      </h4>
                      <div style="font-size: 11px; color: #aaa; margin-bottom: 10px;">
                        個人現金: $${tenant.personalResources?.cash || 0}
                      </div>
                      ${skills
                        .map(
                          (skill) => `
                        <div class="skill-actions">
                          <h5 style="margin: 5px 0; color: #ffcc66;">${skill.name}</h5>
                          <p style="margin: 5px 0; font-size: 12px;">${skill.description}</p>
                          <button class="btn success" onclick="useSkillFromMenu('${tenant.name}', '${skill.id}')">
                            使用技能
                          </button>
                        </div>
                      `
                        )
                        .join("")}
                    </div>
                  `;
            })
            .join("");
    }

    modal.style.display = "block";
}

async function useSkillFromMenu(tenantName, skillId) {
    const result = await useSkill(tenantName, skillId);
    
    if (result.success) {
        addLog(`技能 ${result.skillName} 執行成功`, 'skill');
    } else {
        addLog(`技能執行失敗: ${result.reason}`, 'danger');
    }
    
    closeModal();
    updateDisplay();
}

function getRoomIdByTenant(tenant) {
    const room = gameState.rooms.find((r) => r.tenant === tenant);
    return room ? room.id : "未知";
}

function selectRoom(roomId) {
    const room = gameState.rooms.find((r) => r.id === roomId);
    if (room.tenant) {
        alert(`房間 ${roomId} - ${room.tenant.name} (${room.tenant.typeName})`);
    } else {
        alert(`房間 ${roomId} - 空房`);
    }
}

function nextDay() {
    // 基本的日期推進邏輯
    gameState.day++;
    gameState.harvestUsed = false;
    gameState.scavengeUsed = 0;
    gameState.rentCollected = false;
    
    // 處理租客日常更新
    if (tenantSystem) {
        tenantSystem.updateDailyTenantStates();
    }

    // 房東消費食物
    if (gameState.resources.food >= 2) {
        gameState.resources.food -= 2;
        gameState.landlordHunger = Math.max(0, gameState.landlordHunger - 1);
        addLog("房東消耗了 2 食物", "event");
    } else {
        gameState.landlordHunger += 1;
        addLog("房東沒有足夠食物！", "danger");
    }
    
    // 燃料消費
    if (gameState.resources.fuel > 0) {
        gameState.resources.fuel -= 1;
        addLog("消耗了 1 燃料", "event");
    }
    
    addLog("新的一天開始了", "event");
    updateDisplay();
}

function closeModal() {
    document.querySelectorAll(".modal").forEach((modal) => {
        modal.style.display = "none";
    });
}

// 新增系統資訊功能
function showSystemInfo() {
    if (!gameBridge) {
        alert("系統橋接器未初始化");
        return;
    }

    const info = gameBridge.getSystemInfo();
    const modal = document.getElementById("systemInfoModal");
    const content = document.getElementById("systemInfoContent");
    
    content.innerHTML = `
        <h4>系統架構資訊</h4>
        <p><strong>版本:</strong> ${info.version}</p>
        <p><strong>模式:</strong> ${info.mode}</p>
        
        <h4>DataManager</h4>
        <p><strong>狀態:</strong> ${info.dataManager.available ? '✅ 可用' : '❌ 不可用'}</p>
        <p><strong>已載入資料:</strong> ${info.dataManager.loadedTypes.join(', ') || '無'}</p>
        
        <h4>RuleEngine</h4>
        <p><strong>狀態:</strong> ${info.ruleEngine.available ? '✅ 可用' : '❌ 不可用'}</p>
        <p><strong>規則數量:</strong> ${info.ruleEngine.ruleCount}</p>
                
        <h4>業務系統</h4>
        <p><strong>TenantSystem:</strong> ${tenantSystem ? '✅ 可用' : '❌ 不可用'}</p>
        <p><strong>SkillSystem:</strong> ${skillSystem && skillSystem.initialized ? '✅ 可用' : '❌ 不可用'}</p>

        <h4>遊戲狀態</h4>
        <p><strong>當前天數:</strong> ${gameState.day}</p>
        <p><strong>現金:</strong> $${gameState.resources.cash}</p>
        <p><strong>租客數量:</strong> ${gameState.rooms.filter(r => r.tenant).length}</p>
    `;
    
    modal.style.display = "block";
}

// ==================== 遊戲啟動 ====================
// 頁面載入完成後初始化遊戲
document.addEventListener('DOMContentLoaded', () => {
    console.log('🎮 末日房東模擬器 v1.1 - 重構版啟動');
    initializeGame();
    
    // 初始化遊戲記錄
    addLog("歡迎來到末日房東模擬器重構版！", "event");
    addLog("當前使用先進的混合架構系統", "event");
    addLog("點擊右上角系統狀態查看詳細資訊", "event");
});
</script>
</body>
</html>