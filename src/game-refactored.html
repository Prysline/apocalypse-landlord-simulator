<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ«æ—¥æˆ¿æ±æ¨¡æ“¬å™¨ - é‡æ§‹ç‰ˆ</title>
    <style>
/* === ä¿æŒåŸæœ‰æ¨£å¼ç³»çµ± === */
body {
  font-family: "Courier New", monospace;
  background-color: #2a2a2a;
  color: #e0e0e0;
  margin: 0;
  padding: 20px;
  line-height: 1.4;
}

.game-container {
  max-width: 1200px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: 1fr 300px;
  gap: 20px;
}

.main-area {
  background: #1a1a1a;
  border: 2px solid #555;
  border-radius: 8px;
  padding: 20px;
}

.sidebar {
  background: #1a1a1a;
  border: 2px solid #555;
  border-radius: 8px;
  padding: 15px;
}

.status-bar {
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
  font-size: 14px;
  flex-wrap: wrap;
}

.status-bar > div {
  padding: 4px 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  border: 1px solid #555;
}

#buildingDefenseText {
  color: #66ccff;
}

#landlordHungerText {
  color: #ffcc66;
}

.danger-status {
  color: #ff6666 !important;
  animation: pulse 2s infinite;
}

.good-status {
  color: #66ff66 !important;
}

.house-layout {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  margin-bottom: 20px;
}

.room {
  aspect-ratio: 1;
  border: 2px solid #666;
  background: #333;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
}

.room:hover {
  border-color: #888;
  background: #444;
}

.room.occupied {
  background: #2d4a2d;
  border-color: #4a7c59;
}

.room.needs-repair {
  background: #4a2d2d;
  border-color: #7c4a4a;
}

.room.infected {
  background: #4a2d2d;
  border-color: #cc4444;
  animation: pulse 2s infinite;
}

.room.reinforced {
  border-color: #4a7c9a;
  box-shadow: inset 0 0 10px rgba(74, 124, 154, 0.3);
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.tenant-info {
  font-size: 12px;
  text-align: center;
}

.resources {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  margin-bottom: 20px;
}

.resource {
  background: #333;
  padding: 10px;
  border-radius: 4px;
  text-align: center;
}

.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 20px;
}

.btn {
  background: #4a4a4a;
  border: 1px solid #666;
  color: #e0e0e0;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s;
}

.btn:hover {
  background: #555;
}

.btn:disabled {
  background: #333;
  color: #666;
  cursor: not-allowed;
}

.btn.danger {
  background: #664444;
  border-color: #aa6666;
}

.btn.success {
  background: #446644;
  border-color: #66aa66;
}

.btn.special {
  background: #666644;
  border-color: #aaaa66;
}

.log {
  background: #222;
  border: 1px solid #444;
  height: 150px;
  overflow-y: auto;
  padding: 10px;
  font-size: 12px;
}

.log-entry {
  margin-bottom: 5px;
  padding: 2px 0;
}

.log-entry.event { color: #ffcc66; }
.log-entry.rent { color: #66ff66; }
.log-entry.danger { color: #ff6666; }
.log-entry.skill { color: #66ccff; }

.tenant-list {
  margin-bottom: 15px;
}

.tenant-item {
  background: #333;
  margin: 5px 0;
  padding: 8px;
  border-radius: 4px;
  font-size: 12px;
}

.tenant-item.infected {
  background: #663333;
  border-left: 3px solid #cc4444;
}

.tenant-item.doctor { border-left: 3px solid #66cc66; }
.tenant-item.worker { border-left: 3px solid #cc8866; }
.tenant-item.soldier { border-left: 3px solid #cc6666; }
.tenant-item.farmer { border-left: 3px solid #66aa44; }

.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  z-index: 1000;
}

.modal-content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #2a2a2a;
  border: 2px solid #666;
  border-radius: 8px;
  padding: 20px;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
}

.applicant {
  background: #333;
  margin: 10px 0;
  padding: 10px;
  border-radius: 4px;
}

.applicant.infected {
  background: #663333;
  border: 2px solid #cc4444;
}

.applicant.trader {
  background: #334466;
  border: 2px solid #6688aa;
}

.modal-content p {
  margin: 6px 0;
  font-size: 13px;
  line-height: 1.5;
}

.modal-content .action-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 15px;
  justify-content: flex-end;
}

.tenant-skill-group {
  background: #2d3d2d;
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 15px;
  border-left: 4px solid #66ccff;
}

.skill-actions {
  background: #1e2e1e;
  padding: 10px;
  border-radius: 4px;
  margin: 8px 0;
  border-left: 3px solid #ffcc66;
}

.skill-actions h5 {
  margin: 0 0 5px 0;
  color: #ffcc66;
}

.skill-actions p {
  margin: 5px 0;
  font-size: 12px;
  color: #ccc;
}

/* æ–°å¢ï¼šç³»çµ±ç‹€æ…‹æŒ‡ç¤ºå™¨ */
.system-status {
  position: fixed;
  top: 10px;
  right: 10px;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 11px;
  z-index: 2000;
}

.system-status.legacy { color: #ff9966; }
.system-status.hybrid { color: #66ccff; }
.system-status.new { color: #66ff66; }
    </style>
</head>
<body>
    <!-- ç³»çµ±ç‹€æ…‹æŒ‡ç¤ºå™¨ -->
    <div id="systemStatus" class="system-status hybrid">
        ğŸ”„ æ··åˆç³»çµ± v1.0
    </div>

    <div class="game-container">
        <div class="main-area">
            <div class="status-bar">
                <div>ç¬¬ <span id="day">1</span> å¤©</div>
                <div>æ™‚é–“: <span id="time">ç™½å¤©</span></div>
                <div>ğŸ’° ç¾é‡‘: $<span id="cash">50</span></div>
                <div>ğŸ›¡ï¸ é˜²ç¦¦: <span id="buildingDefenseText">è„†å¼±(0)</span></div>
                <div>ğŸ½ï¸ é£¢é¤“: <span id="landlordHungerText">é£½è¶³(0)</span></div>
            </div>

            <div class="house-layout">
                <div class="room" id="room1" onclick="selectRoom(1)">
                    <div class="tenant-info" id="room1-info">ç©ºæˆ¿</div>
                </div>
                <div class="room" id="room2" onclick="selectRoom(2)">
                    <div class="tenant-info" id="room2-info">ç©ºæˆ¿</div>
                </div>
            </div>

            <div class="resources">
                <div class="resource">ğŸ– é£Ÿç‰©: <span id="food">20</span></div>
                <div class="resource">ğŸ”§ å»ºæ: <span id="materials">15</span></div>
                <div class="resource">ğŸ’Š é†«ç™‚: <span id="medical">10</span></div>
                <div class="resource">â›½ ç‡ƒæ–™: <span id="fuel">8</span></div>
            </div>

            <div class="controls">
                <button class="btn success" onclick="collectRent()">æ”¶ç§Ÿ</button>
                <button class="btn" onclick="showVisitors()">æŸ¥çœ‹è¨ªå®¢</button>
                <button class="btn" onclick="showScavengeMenu()">æ´¾é£æœåˆ® (<span id="scavengeCount">0</span>/2)</button>
                <button class="btn" onclick="harvestYard()">é™¢å­æ¡é›†</button>
                <button class="btn special" onclick="showSkillMenu()">ä½¿ç”¨æŠ€èƒ½</button>
                <button class="btn danger" onclick="nextDay()">ä¸‹ä¸€å¤©</button>
            </div>

            <div class="log" id="gameLog">
                <div class="log-entry">éŠæˆ²é–‹å§‹ï¼ä½ ç¹¼æ‰¿äº†é€™æ£Ÿè€æˆ¿å­ï¼Œæœ«æ—¥ä¸­çš„å€–å­˜è€…å€‘æ­£åœ¨å°‹æ‰¾ä½æ‰€...</div>
            </div>
        </div>

        <div class="sidebar">
            <h3>ç§Ÿå®¢åˆ—è¡¨</h3>
            <div class="tenant-list" id="tenantList">
                <div class="tenant-item">æš«ç„¡ç§Ÿå®¢</div>
            </div>

            <h3>æ¥­å‹™ç³»çµ±ç‹€æ…‹</h3>
            <div class="business-system-status">
                <div><span class="status-indicator loading" id="tenantSystemStatus"></span>ç§Ÿå®¢ç³»çµ±: <span id="tenantSystemText">è¼‰å…¥ä¸­...</span></div>
                <div><span class="status-indicator loading" id="skillSystemStatus"></span>æŠ€èƒ½ç³»çµ±: <span id="skillSystemText">è¼‰å…¥ä¸­...</span></div>
                <div><span class="status-indicator loading" id="integrationStatus"></span>ç³»çµ±æ•´åˆ: <span id="integrationText">è¼‰å…¥ä¸­...</span></div>
            </div>

            <h3>ç³»çµ±è³‡è¨Š</h3>
            <div style="font-size: 11px;">
                <p>â€¢ æ¶æ§‹ç‰ˆæœ¬: <span id="archVersion">æ··åˆ v1.0</span></p>
                <p>â€¢ è³‡æ–™ç³»çµ±: <span id="dataSystem">è¼‰å…¥ä¸­...</span></p>
                <p>â€¢ è¦å‰‡å¼•æ“: <span id="ruleEngine">è¼‰å…¥ä¸­...</span></p>
                <button class="btn" onclick="showSystemInfo()" style="width: 100%; margin-top: 5px;">ç³»çµ±ç‹€æ…‹</button>
            </div>

            <h3>éŠæˆ²èªªæ˜</h3>
            <div style="font-size: 11px;">
                <p>â€¢ é»æ“Šæˆ¿é–“æŸ¥çœ‹è©³æƒ…</p>
                <p>â€¢ é‚€è«‹è¨ªå®¢ç§Ÿæˆ¿æˆ–äº¤æ˜“</p>
                <p>â€¢ å•†äººè¨ªå®¢æä¾›å„ç¨®äº¤æ˜“</p>
                <p>â€¢ ç§Ÿå®¢å¯ç”¨è³‡æºæŠµä»˜æˆ¿ç§Ÿ</p>
                <p>â€¢ å–„ç”¨ç§Ÿå®¢æŠ€èƒ½æ±‚ç”Ÿ</p>
                <p>â€¢ æˆ¿æ±ä¹Ÿéœ€è¦é£Ÿç‰©ç¶­ç”Ÿ</p>
                <p>â€¢ ç•™æ„å•†éšŠå’Œæµæµªå•†äºº</p>
            </div>
        </div>
    </div>

    <!-- ç¾æœ‰çš„æ¨¡æ…‹æ¡†HTMLä¿æŒä¸è®Š -->
    <div class="modal" id="visitorModal">
        <div class="modal-content">
            <h3>ä»Šæ—¥è¨ªå®¢</h3>
            <div id="visitorList"></div>
            <button class="btn" onclick="closeModal()">é—œé–‰</button>
        </div>
    </div>

    <div class="modal" id="tenantModal">
        <div class="modal-content">
            <h3 id="tenantModalTitle">ç§Ÿå®¢ç®¡ç†</h3>
            <div id="tenantModalContent"></div>
            <div id="tenantModalActions" class="action-buttons"></div>
        </div>
    </div>

    <div class="modal" id="scavengeModal">
        <div class="modal-content">
            <h3>é¸æ“‡æ´¾é£äººå“¡</h3>
            <p>å‰©ä½™æ´¾é£æ¬¡æ•¸: <span id="remainingScavenges">2</span></p>
            <div id="availableTenants"></div>
            <button class="btn" onclick="closeModal()">å–æ¶ˆ</button>
        </div>
    </div>

    <div class="modal" id="skillModal">
        <div class="modal-content">
            <h3>ç§Ÿå®¢æŠ€èƒ½</h3>
            <div id="skillList"></div>
            <button class="btn" onclick="closeModal()">é—œé–‰</button>
        </div>
    </div>

    <div class="modal" id="eventModal">
        <div class="modal-content">
            <h3 id="eventTitle">äº‹ä»¶</h3>
            <p id="eventDescription"></p>
            <div id="eventChoices"></div>
        </div>
    </div>

    <div class="modal" id="systemInfoModal">
        <div class="modal-content">
            <h3>ç³»çµ±ç‹€æ…‹è³‡è¨Š</h3>
            <div id="systemInfoContent"></div>
            <button class="btn" onclick="closeModal()">é—œé–‰</button>
        </div>
    </div>

<script>
// ==================== æ ¸å¿ƒæ¶æ§‹ç³»çµ± ====================

/**
 * DataManager - è³‡æ–™ç®¡ç†æ ¸å¿ƒ
 * å…§åµŒç‰ˆæœ¬ï¼Œé©é…å–®ä¸€HTMLæª”æ¡ˆæ¶æ§‹
 */
const GameCore = (() => {
    'use strict';

    // DataManager æ¨¡çµ„
    class DataManager {
        constructor() {
            this.cache = new Map();
            this.validators = new Map();
            this.loadPromises = new Map();
            this.registerValidators();
        }

        registerValidators() {
            this.validators.set('tenants', (data) => {
                if (!Array.isArray(data)) throw new Error('ç§Ÿå®¢è³‡æ–™å¿…é ˆæ˜¯é™£åˆ—');
                data.forEach((tenant, index) => {
                    const required = ['typeId', 'typeName', 'category', 'rent', 'skill', 'infectionRisk'];
                    required.forEach(field => {
                        if (!(field in tenant)) {
                            throw new Error(`ç§Ÿå®¢ ${index}: ç¼ºå°‘å¿…è¦æ¬„ä½ ${field}`);
                        }
                    });
                });
                return true;
            });

            this.validators.set('skills', (data) => {
                if (typeof data !== 'object' || data === null) {
                    throw new Error('æŠ€èƒ½è³‡æ–™å¿…é ˆæ˜¯ç‰©ä»¶');
                }
                return true;
            });
        }

        async loadData(dataType, forceReload = false) {
            if (!forceReload && this.cache.has(dataType)) {
                return this.cache.get(dataType);
            }

            if (this.loadPromises.has(dataType)) {
                return this.loadPromises.get(dataType);
            }

            const loadPromise = this._loadFromFile(dataType);
            this.loadPromises.set(dataType, loadPromise);

            try {
                const data = await loadPromise;
                this.validateData(dataType, data);
                this.cache.set(dataType, data);
                console.log(`âœ… æˆåŠŸè¼‰å…¥ ${dataType} è³‡æ–™`);
                return data;
            } catch (error) {
                console.warn(`âš ï¸ è¼‰å…¥ ${dataType} å¤±æ•—ï¼Œä½¿ç”¨é è¨­è³‡æ–™:`, error.message);
                const defaultData = this.getDefaultData(dataType);
                this.cache.set(dataType, defaultData);
                return defaultData;
            } finally {
                this.loadPromises.delete(dataType);
            }
        }

        async _loadFromFile(dataType) {
            const filename = `data/${dataType}.json`;
            const response = await fetch(filename);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        }

        validateData(dataType, data) {
            const validator = this.validators.get(dataType);
            if (validator) {
                return validator(data);
            }
            return true;
        }

        getDefaultData(dataType) {
            const defaults = {
                tenants: window.tenantTypes || [],
                skills: {},
                events: window.events || [],
                rules: {
                    gameBalance: { landlordDailyFood: 2 },
                    mechanics: { maxScavengePerDay: 2 }
                }
            };
            return defaults[dataType] || {};
        }

        getCachedData(dataType) {
            return this.cache.get(dataType);
        }

        isDataLoaded(dataType) {
            return this.cache.has(dataType);
        }
    }

    // RuleEngine æ¨¡çµ„
    class RuleEngine {
        constructor(gameStateRef) {
            this.gameState = gameStateRef;
            this.rules = new Map();
            this.executionHistory = [];
            this.conditionCheckers = new Map();
            this.effectExecutors = new Map();
            
            this.registerBuiltinConditions();
            this.registerBuiltinEffects();
        }

        registerBuiltinConditions() {
            this.conditionCheckers.set('hasResource', (condition, gameState) => {
                const { resource, amount } = condition;
                return (gameState.resources[resource] || 0) >= amount;
            });

            this.conditionCheckers.set('probability', (condition, gameState) => {
                return Math.random() < condition.chance;
            });
        }

        registerBuiltinEffects() {
            this.effectExecutors.set('modifyResource', (effect, gameState) => {
                const { resource, amount } = effect;
                const oldValue = gameState.resources[resource] || 0;
                gameState.resources[resource] = Math.max(0, oldValue + amount);
                return { type: 'resource', resource, amount, newValue: gameState.resources[resource] };
            });

            this.effectExecutors.set('logMessage', (effect, gameState) => {
                const { message, logType = 'event' } = effect;
                if (typeof addLog === 'function') {
                    addLog(message, logType);
                }
                return { type: 'log', message, logType };
            });
        }

        registerRule(ruleId, ruleConfig) {
            const rule = {
                id: ruleId,
                name: ruleConfig.name || ruleId,
                conditions: ruleConfig.conditions || [],
                effects: ruleConfig.effects || [],
                enabled: ruleConfig.enabled !== false
            };
            this.rules.set(ruleId, rule);
            return rule;
        }

        executeRule(ruleId, context = {}) {
            const rule = this.rules.get(ruleId);
            if (!rule || !rule.enabled) {
                return { executed: false, reason: 'rule_not_available' };
            }

            const conditionsMet = this.checkAllConditions(rule.conditions, context);
            if (!conditionsMet) {
                return { executed: false, reason: 'conditions_not_met' };
            }

            const results = [];
            rule.effects.forEach(effect => {
                try {
                    const result = this.executeEffect(effect, this.gameState);
                    results.push(result);
                } catch (error) {
                    console.error(`âŒ è¦å‰‡ ${ruleId} æ•ˆæœåŸ·è¡Œå¤±æ•—:`, error);
                    results.push({ type: 'error', error: error.message });
                }
            });

            return { executed: true, results };
        }

        checkAllConditions(conditions, context = {}) {
            if (!conditions || conditions.length === 0) return true;
            return conditions.every(condition => this.checkCondition(condition, context));
        }

        checkCondition(condition, context = {}) {
            const { type } = condition;
            const checker = this.conditionCheckers.get(type);
            if (!checker) {
                console.warn(`âš ï¸ æœªçŸ¥çš„æ¢ä»¶é¡å‹: ${type}`);
                return false;
            }
            try {
                return checker(condition, { ...this.gameState, ...context });
            } catch (error) {
                console.error(`âŒ æ¢ä»¶æª¢æŸ¥å¤±æ•— (${type}):`, error);
                return false;
            }
        }

        executeEffect(effect, gameState) {
            const { type } = effect;
            const executor = this.effectExecutors.get(type);
            if (!executor) {
                console.warn(`âš ï¸ æœªçŸ¥çš„æ•ˆæœé¡å‹: ${type}`);
                return { type: 'unknown', originalEffect: effect };
            }
            try {
                return executor(effect, gameState);
            } catch (error) {
                console.error(`âŒ æ•ˆæœåŸ·è¡Œå¤±æ•— (${type}):`, error);
                return { type: 'error', error: error.message };
            }
        }
    }

    // GameBridge æ¨¡çµ„ï¼ˆç°¡åŒ–ç‰ˆï¼‰
    class GameBridge {
        constructor(originalGameState) {
            this.originalGameState = originalGameState;
            this.systemStatus = { hybrid: true, version: '1.0.0' };
            this.dataManager = new DataManager();
            this.ruleEngine = new RuleEngine(originalGameState);
        }

        async initialize() {
            console.log('ğŸŒ‰ åˆå§‹åŒ–éŠæˆ²æ©‹æ¥ç³»çµ±...');
            
            try {
                // å˜—è©¦è¼‰å…¥æ–°è³‡æ–™
                const dataTypes = ['tenants', 'skills', 'events', 'rules'];
                for (const dataType of dataTypes) {
                    await this.dataManager.loadData(dataType);
                }
                
                this.systemStatus.dataSystemReady = true;
                console.log('âœ… æ©‹æ¥ç³»çµ±åˆå§‹åŒ–å®Œæˆ');
                this.updateSystemStatus();
                
            } catch (error) {
                console.warn('âš ï¸ æ©‹æ¥ç³»çµ±éƒ¨åˆ†åŠŸèƒ½ä¸å¯ç”¨:', error.message);
                this.systemStatus.dataSystemReady = false;
                this.updateSystemStatus();
            }
        }

        updateSystemStatus() {
            const statusEl = document.getElementById('systemStatus');
            const dataSystemEl = document.getElementById('dataSystem');
            const ruleEngineEl = document.getElementById('ruleEngine');

            if (statusEl) {
                statusEl.textContent = this.systemStatus.dataSystemReady ? 
                    'ğŸŸ¢ æ··åˆç³»çµ± - é‹è¡Œä¸­' : 'ğŸŸ¡ æ··åˆç³»çµ± - é™ç´šæ¨¡å¼';
            }
            
            if (dataSystemEl) {
                dataSystemEl.textContent = this.systemStatus.dataSystemReady ? 'âœ… å·²è¼‰å…¥' : 'âŒ ä½¿ç”¨é è¨­';
            }
            
            if (ruleEngineEl) {
                ruleEngineEl.textContent = this.ruleEngine ? 'âœ… å°±ç·’' : 'âŒ ä¸å¯ç”¨';
            }
        }

        getSystemInfo() {
            return {
                version: this.systemStatus.version,
                mode: this.systemStatus.dataSystemReady ? 'hybrid' : 'legacy',
                dataManager: {
                    available: !!this.dataManager,
                    loadedTypes: Array.from(this.dataManager.cache.keys())
                },
                ruleEngine: {
                    available: !!this.ruleEngine,
                    ruleCount: this.ruleEngine.rules.size
                }
            };
        }
    }

    // æ¨¡çµ„åŒ¯å‡º
    return {
        DataManager,
        RuleEngine, 
        GameBridge
    };
})();

// ==================== å…§åµŒæ¥­å‹™ç³»çµ± ====================

// ç°¡åŒ–ç‰ˆçš„TenantSystem (å…§åµŒå¯¦ä½œ)
class TenantSystem {
    constructor(gameStateRef, dataManager) {
        this.gameState = gameStateRef;
        this.dataManager = dataManager;
        this.tenantStates = new Map();

        this.idCounter = 0;
    }

    // æ–°å¢ï¼šç”Ÿæˆå”¯ä¸€IDçš„æ–¹æ³•
    generateUniqueId() {
        const timestamp = Date.now();
        const random = Math.floor(Math.random() * 10000);
        const counter = ++this.idCounter;
        return `${timestamp}_${random}_${counter}`;
    }

    generateApplicants(count = null) {
        if (count === null) {
            count = Math.floor(Math.random() * 3) + 1;
        }

        const tenantConfigs = this.dataManager.getCachedData('tenants');
        if (!tenantConfigs) {
            console.warn('âš ï¸ ç§Ÿå®¢é…ç½®ä¸å¯ç”¨ï¼Œä½¿ç”¨é è¨­ç”Ÿæˆ');
            return this.generateDefaultApplicants(count);
        }

        const availableTenants = this.filterAvailableTenants(tenantConfigs);
        const applicants = [];
        
        for (let i = 0; i < count; i++) {
            const config = availableTenants[Math.floor(Math.random() * availableTenants.length)];
            const applicant = this.createApplicantFromConfig(config);
            applicants.push(applicant);
        }

        console.log(`ğŸ“‹ ç”Ÿæˆäº† ${count} å€‹ç”³è«‹è€…`);
        return applicants;
    }

    filterAvailableTenants(tenantConfigs) {
        return tenantConfigs.filter(config => {
            const unlockConditions = config.unlockConditions;
            if (!unlockConditions) return true;

            if (unlockConditions.day && this.gameState.day < unlockConditions.day) {
                return false;
            }

            if (unlockConditions.buildingDefense && 
                this.gameState.buildingDefense < unlockConditions.buildingDefense) {
                return false;
            }

            if (unlockConditions.totalTenants) {
                const currentTenants = this.gameState.rooms.filter(r => r.tenant).length;
                if (currentTenants < unlockConditions.totalTenants) {
                    return false;
                }
            }

            return true;
        });
    }

    createApplicantFromConfig(config) {
        return {
            ...config,
            id: this.generateUniqueId(),
            name: this.generateName(),
            infected: Math.random() < config.infectionRisk,
            personalResources: { ...config.personalResources },
            appearance: Math.random() < config.infectionRisk ? 
                this.getInfectedAppearance() : this.getNormalAppearance()
        };
    }

    hireTenant(applicant, roomId = null) {
        const room = roomId ? 
            this.gameState.rooms.find(r => r.id === roomId) :
            this.gameState.rooms.find(r => !r.tenant);

        if (!room) {
            console.warn('âŒ æ²’æœ‰å¯ç”¨æˆ¿é–“');
            return false;
        }

        const tenant = { ...applicant };
        room.tenant = tenant;

        // åˆå§‹åŒ–ç§Ÿå®¢ç‹€æ…‹
        this.tenantStates.set(tenant.name, {
            satisfaction: 50,
            healthStatus: 'healthy',
            lastInteraction: this.gameState.day
        });

        if (!this.gameState.tenantSatisfaction) {
            this.gameState.tenantSatisfaction = {};
        }
        this.gameState.tenantSatisfaction[tenant.name] = 50;

        addLog(`æ–°ç§Ÿå®¢ ${tenant.name} å…¥ä½æˆ¿é–“ ${room.id}`, 'rent');
        return true;
    }

    evictTenant(tenantName, reason = 'evicted') {
        const room = this.gameState.rooms.find(r => r.tenant && r.tenant.name === tenantName);
        if (!room) {
            console.warn(`âŒ æ‰¾ä¸åˆ°ç§Ÿå®¢: ${tenantName}`);
            return false;
        }

        const tenant = room.tenant;
        
        // è™•ç†é›¢é–‹å¾Œæœ
        if (reason === 'infected' && this.gameState.resources.medical >= 2) {
            this.gameState.resources.medical -= 2;
            addLog('æ¶ˆæ¯’æ„ŸæŸ“æˆ¿é–“èŠ±è²»äº† 2 é†«ç™‚ç”¨å“', 'danger');
        }

        room.tenant = null;
        this.tenantStates.delete(tenantName);
        if (this.gameState.tenantSatisfaction) {
            delete this.gameState.tenantSatisfaction[tenantName];
        }

        addLog(`ç§Ÿå®¢ ${tenantName} é›¢é–‹äº†æˆ¿é–“ ${room.id}`, 
               reason === 'infected' ? 'danger' : 'event');
        return true;
    }

    updateDailyTenantStates() {
        const occupiedRooms = this.gameState.rooms.filter(room => room.tenant);
        
        occupiedRooms.forEach(room => {
            const tenant = room.tenant;
            const tenantState = this.tenantStates.get(tenant.name);
            
            if (tenantState) {
                this.updateTenantSatisfaction(tenant, room, tenantState);
            }
        });
    }

    updateTenantSatisfaction(tenant, room, tenantState) {
        let satisfaction = tenantState.satisfaction;
        
        if (room.reinforced) satisfaction += 3;
        if (room.needsRepair) satisfaction -= 8;
        if (tenant.personalResources && tenant.personalResources.food < 2) satisfaction -= 10;
        
        if (this.gameState.buildingDefense >= 8) satisfaction += 4;
        if (this.gameState.buildingDefense <= 2) satisfaction -= 6;

        satisfaction = Math.max(0, Math.min(100, satisfaction));
        tenantState.satisfaction = satisfaction;
        if (this.gameState.tenantSatisfaction) {
            this.gameState.tenantSatisfaction[tenant.name] = satisfaction;
        }
    }

    generateDefaultApplicants(count) {
        const defaultTypes = ['doctor', 'worker', 'farmer', 'soldier', 'elder'];
        const applicants = [];
        
        for (let i = 0; i < count; i++) {
            const type = defaultTypes[Math.floor(Math.random() * defaultTypes.length)];
            const applicant = {
                id: Date.now() + i,
                name: this.generateName(),
                type: type,
                rent: [15, 12, 10, 18, 8][defaultTypes.indexOf(type)],
                infected: Math.random() < 0.2,
                personalResources: { food: 5, materials: 2, medical: 2, cash: 20 },
                appearance: Math.random() < 0.2 ? this.getInfectedAppearance() : this.getNormalAppearance()
            };
            applicants.push(applicant);
        }
        
        return applicants;
    }

    generateName() {
        const names = ['å°æ˜', 'å°è¯', 'å°æ', 'è€ç‹', 'é˜¿å¼·', 'å°ç¾', 'é˜¿ç', 'å¤§é›„'];
        return names[Math.floor(Math.random() * names.length)];
    }

    getNormalAppearance() {
        const appearances = ['çœ‹èµ·ä¾†ç²¾ç¥ç‹€æ…‹ä¸éŒ¯', 'è¡£è‘—æ•´æ½”ï¼Œè«‡åå¾—é«”', 'çœ¼ç¥æ¸…æ¾ˆï¼Œåæ‡‰éˆæ•'];
        return appearances[Math.floor(Math.random() * appearances.length)];
    }

    getInfectedAppearance() {
        const appearances = ['çœ¼ç¥æœ‰é»å‘†æ»¯ï¼Œåæ‡‰é²éˆ', 'çš®è†šè’¼ç™½ï¼Œæ‰‹æœ‰è¼•å¾®é¡«æŠ–', 'æœ‰è‚¡å¥‡æ€ªçš„å‘³é“'];
        return appearances[Math.floor(Math.random() * appearances.length)];
    }
}

// ç°¡åŒ–ç‰ˆçš„SkillSystem (å…§åµŒå¯¦ä½œ)
class SkillSystem {
    constructor(gameStateRef, dataManager) {
        this.gameState = gameStateRef;
        this.dataManager = dataManager;
        this.skillRegistry = new Map();
        this.cooldownManager = new Map(); // tenantName_skillId -> expireDay
        this.usageCounter = new Map(); // tenantName_skillId -> count
        this.permanentUsage = new Map(); // tenantName_skillId -> boolean
        this.initialized = false;
    }

    async initializeSystem() {
        try {
            const skillConfigs = this.dataManager.getCachedData('skills');
            if (skillConfigs) {
                Object.entries(skillConfigs).forEach(([tenantType, skills]) => {
                    this.skillRegistry.set(tenantType, skills);
                });
            }
            this.initialized = true;
            console.log('âœ… SkillSystem åˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
            console.error('âŒ SkillSystem åˆå§‹åŒ–å¤±æ•—:', error);
        }
    }

    async executeSkill(tenantName, skillId) {
        if (!this.initialized) {
            console.warn('âš ï¸ SkillSystem æœªåˆå§‹åŒ–ï¼Œä½¿ç”¨åŸå§‹å¯¦ä½œ');
            return { success: false, reason: 'system_not_ready' };
        }

        const tenant = this.findTenantByName(tenantName);
        if (!tenant) {
            return { success: false, reason: 'tenant_not_found' };
        }

        const skillConfig = this.getSkillConfig(tenant.typeId, skillId);
        if (!skillConfig) {
            return { success: false, reason: 'skill_not_found' };
        }

        // æª¢æŸ¥å†·å»æ™‚é–“
        if (this.isOnCooldown(tenantName, skillId)) {
            const remaining = this.getCooldownRemaining(tenantName, skillId);
            return { 
                success: false, 
                reason: 'on_cooldown',
                message: `æŠ€èƒ½å†·å»ä¸­ï¼Œé‚„éœ€ ${remaining} å¤©`
            };
        }

        // æª¢æŸ¥æ°¸ä¹…æ€§æŠ€èƒ½ä½¿ç”¨é™åˆ¶
        if (skillConfig.cooldown === -1 && this.isPermanentSkillUsed(tenantName, skillId)) {
            return { 
                success: false, 
                reason: 'permanent_skill_used',
                message: 'æ­¤æŠ€èƒ½åªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼Œå·²ç¶“ä½¿ç”¨éäº†'
            };
        }

        // æª¢æŸ¥ä½¿ç”¨æ¬¡æ•¸é™åˆ¶
        if (skillConfig.maxUses && this.getSkillUsageCount(tenantName, skillId) >= skillConfig.maxUses) {
            return { 
                success: false, 
                reason: 'max_uses_exceeded',
                message: `æŠ€èƒ½ä½¿ç”¨æ¬¡æ•¸å·²é”ä¸Šé™ (${skillConfig.maxUses})`
            };
        }

        // æª¢æŸ¥æˆæœ¬
        if (!this.canAffordSkill(skillConfig)) {
            return { success: false, reason: 'insufficient_resources' };
        }

        // æ”¯ä»˜æˆæœ¬
        this.paySkillCost(skillConfig, tenant);

        // åŸ·è¡Œæ•ˆæœ
        const effects = this.executeSkillEffects(skillConfig, tenant);

        // è¨­å®šå†·å»æ™‚é–“
        this.setSkillCooldown(tenantName, skillId, skillConfig.cooldown || 0);

        // è¨˜éŒ„ä½¿ç”¨æ¬¡æ•¸
        this.incrementSkillUsage(tenantName, skillId);

        // å¦‚æœæ˜¯æ°¸ä¹…æ€§æŠ€èƒ½ï¼Œæ¨™è¨˜ç‚ºå·²ä½¿ç”¨
        if (skillConfig.cooldown === -1) {
            this.markPermanentSkillUsed(tenantName, skillId);
        }

        addLog(`${tenant.name} ä½¿ç”¨äº†æŠ€èƒ½ï¼š${skillConfig.name}`, 'skill');

        return {
            success: true,
            skillId: skillConfig.id,
            skillName: skillConfig.name,
            effects
        };
    }

    findTenantByName(name) {
        const room = this.gameState.rooms.find(r => r.tenant && r.tenant.name === name);
        return room ? room.tenant : null;
    }

    getSkillConfig(tenantType, skillId) {
        const tenantSkills = this.skillRegistry.get(tenantType);
        return tenantSkills ? tenantSkills.find(skill => skill.id === skillId) : null;
    }

    canAffordSkill(skillConfig) {
        const cost = skillConfig.cost || {};
        return Object.keys(cost).every(resource => {
            if (resource === 'cash') {
                return this.gameState.resources.cash >= cost[resource];
            } else {
                return (this.gameState.resources[resource] || 0) >= cost[resource];
            }
        });
    }

    paySkillCost(skillConfig, tenant) {
        const cost = skillConfig.cost || {};
        let totalPayment = 0;

        Object.keys(cost).forEach(resource => {
            const amount = cost[resource];
            
            if (resource === 'cash') {
                this.gameState.resources.cash -= amount;
                totalPayment += amount;
            } else {
                this.gameState.resources[resource] -= amount;
            }
        });

        // æ”¯ä»˜å·¥è³‡çµ¦ç§Ÿå®¢
        if (totalPayment > 0 && tenant && tenant.personalResources) {
            tenant.personalResources.cash = (tenant.personalResources.cash || 0) + totalPayment;
            addLog(`ğŸ’° æ”¯ä»˜ ${tenant.name} å·¥è³‡ $${totalPayment}`, 'rent');
        }
    }

    executeSkillEffects(skillConfig, tenant) {
        const effects = skillConfig.effects || [];
        const results = [];

        effects.forEach(effect => {
            const result = this.executeEffect(effect, tenant);
            results.push(result);
        });

        return results;
    }

    executeEffect(effect, tenant) {
        switch (effect.type) {
            case 'modifyResource':
                const oldValue = this.gameState.resources[effect.resource] || 0;
                this.gameState.resources[effect.resource] = Math.max(0, oldValue + effect.amount);
                return {
                    type: 'resource_modified',
                    resource: effect.resource,
                    amount: effect.amount,
                    newValue: this.gameState.resources[effect.resource]
                };

            case 'healTenant':
                const infectedTenants = this.gameState.rooms
                    .filter(room => room.tenant && room.tenant.infected)
                    .map(room => room.tenant);
                
                if (infectedTenants.length > 0) {
                    const patient = infectedTenants[Math.floor(Math.random() * infectedTenants.length)];
                    patient.infected = false;
                    addLog(`${tenant.name} æ²»ç™’äº† ${patient.name}`, 'skill');
                    return { type: 'tenant_healed', patient: patient.name };
                }
                return { type: 'no_target' };

            case 'repairRoom':
                const needRepairRooms = this.gameState.rooms.filter(r => r.needsRepair);
                if (needRepairRooms.length > 0) {
                    const room = needRepairRooms[0];
                    room.needsRepair = false;
                    addLog(`${tenant.name} ç¶­ä¿®äº†æˆ¿é–“ ${room.id}`, 'skill');
                    return { type: 'room_repaired', roomId: room.id };
                }
                return { type: 'no_target' };

            case 'logMessage':
                addLog(effect.message, effect.logType || 'skill');
                return { type: 'log_message', message: effect.message };

            default:
                console.warn(`âš ï¸ æœªçŸ¥çš„æ•ˆæœé¡å‹: ${effect.type}`);
                return { type: 'unknown', effect };
        }
    }

    getAvailableSkills(tenantName) {
        const tenant = this.findTenantByName(tenantName);
        if (!tenant) return [];

        const tenantSkills = this.skillRegistry.get(tenant.typeId) || [];
        
        return tenantSkills.filter(skill => {
        // 1. éæ¿¾è¢«å‹•æŠ€èƒ½ - è¢«å‹•æŠ€èƒ½ä¸æ‡‰åœ¨æ‰‹å‹•æŠ€èƒ½é¸å–®ä¸­é¡¯ç¤º
        if (skill.type === 'passive') {
            return false;
        }
        
        // 2. æª¢æŸ¥åŸºæœ¬å¯ç”¨æ€§
        if (!this.isSkillAvailable(skill, tenant)) {
            return false;
        }
        
        // 3. æª¢æŸ¥ç‰¹æ®Šéœ€æ±‚æ¢ä»¶
        if (!this.checkSkillRequirements(skill, tenant)) {
            return false;
        }
        
        return true;
    }).map(skill => ({
        ...skill,
        cooldownRemaining: this.getCooldownRemaining(tenant.name, skill.id),
        canAfford: this.canAffordSkill(skill),
        usageCount: this.getSkillUsageCount(tenant.name, skill.id)
    }));
    }

// æ–°å¢ï¼šæª¢æŸ¥æŠ€èƒ½ç‰¹æ®Šéœ€æ±‚
checkSkillRequirements(skill, tenant) {
    const requirements = skill.requirements;
    if (!requirements || !requirements.conditions) return true;
    
    return requirements.conditions.every(condition => {
        switch (condition.type) {
            case 'hasTenantType':
                if (condition.value === 'infected') {
                    const infectedCount = this.gameState.rooms
                        .filter(room => room.tenant && room.tenant.infected).length;
                    return infectedCount >= (condition.count || 1);
                }
                
                if (condition.value === 'any') {
                    const tenantCount = this.gameState.rooms
                        .filter(room => room.tenant).length;
                    return tenantCount >= (condition.count || 1);
                }
                
                const typeCount = this.gameState.rooms
                    .filter(room => room.tenant && room.tenant.typeId === condition.value).length;
                return typeCount >= (condition.count || 1);
                
            case 'gameStateCheck':
                return this.checkGameStateCondition(condition);
                
            case 'hasResource':
                const { resource, amount } = condition;
                return (this.gameState.resources[resource] || 0) >= amount;
                
            default:
                return true;
        }
    });
}

// æª¢æŸ¥éŠæˆ²ç‹€æ…‹æ¢ä»¶
checkGameStateCondition(condition) {
    const { path, operator, value } = condition;
    
    switch (path) {
        case 'rooms':
            if (operator === 'hasNeedsRepair') {
                return this.gameState.rooms.some(room => room.needsRepair);
            }
            if (operator === 'hasUnReinforced') {
                return this.gameState.rooms.some(room => room.tenant && !room.reinforced);
            }
            break;
            
        default:
            const actualValue = this.getNestedValue(this.gameState, path);
            return this.compareValues(actualValue, operator, value);
    }
    
    return false;
}

// å–å¾—å†·å»å‰©é¤˜æ™‚é–“
getCooldownRemaining(tenantName, skillId) {
    const key = `${tenantName}_${skillId}`;
    const expireDay = this.cooldownManager.get(key);
    
    if (!expireDay) return 0;
    
    const currentDay = this.gameState.day;
    return Math.max(0, expireDay - currentDay);
}

// å–å¾—æŠ€èƒ½ä½¿ç”¨æ¬¡æ•¸
getSkillUsageCount(tenantName, skillId) {
    // é€™è£¡éœ€è¦å¯¦ä½œä½¿ç”¨æ¬¡æ•¸è¿½è¹¤é‚è¼¯
    // æš«æ™‚è¿”å›0ï¼Œå¯¦éš›éœ€è¦æ ¹æ“šéŠæˆ²ç‹€æ…‹è¿½è¹¤
    const usageKey = `${tenantName}_${skillId}_used`;
    return this.gameState[usageKey] || 0;
}

isSkillAvailable(skill, tenant) {
    // 1. æª¢æŸ¥å†·å»æ™‚é–“
    if (this.getCooldownRemaining(tenant.name, skill.id) > 0) {
        return false;
    }
    
    // 2. æª¢æŸ¥ä½¿ç”¨æ¬¡æ•¸é™åˆ¶
    if (skill.maxUses && this.getSkillUsageCount(tenant.name, skill.id) >= skill.maxUses) {
        return false;
    }
    
    // 3. æª¢æŸ¥æˆæœ¬
    if (!this.canAffordSkill(skill)) {
        return false;
    }
    
    // 4. æª¢æŸ¥ç§Ÿå®¢å¥åº·ç‹€æ…‹
    if (tenant.infected) {
        return false;
    }
    
    return true;
}
}

// ==================== åŸå§‹éŠæˆ²ç‹€æ…‹ ====================
let gameState = {
    day: 1,
    time: "day",
    resources: { food: 20, materials: 15, medical: 10, fuel: 8, cash: 50 },
    rooms: [
        { id: 1, tenant: null, needsRepair: false, reinforced: false },
        { id: 2, tenant: null, needsRepair: false, reinforced: false }
    ],
    applicants: [],
    visitors: [],
    landlordHunger: 0,
    harvestUsed: false,
    harvestCooldown: 0,
    scavengeUsed: 0,
    maxScavengePerDay: 2,
    rentCollected: false,
    buildingDefense: 0,
    tenantSatisfaction: {},
    harmoniumBonus: 0
};

// ==================== å…¨åŸŸè®Šæ•¸èˆ‡åˆå§‹åŒ– ====================
let gameBridge = null;
let systemIntegrator = null;
let tenantSystem = null;
let skillSystem = null;

// åˆå§‹åŒ–ç³»çµ±
async function initializeGame() {
    try {
      console.log('ğŸ® æœ«æ—¥æˆ¿æ±æ¨¡æ“¬å™¨ v1.1 å•Ÿå‹•ä¸­...');

        gameBridge = new GameCore.GameBridge(gameState);
        await gameBridge.initialize();
        
        // åˆå§‹åŒ–æ¥­å‹™ç³»çµ±
        tenantSystem = new TenantSystem(gameState, gameBridge.dataManager);
        skillSystem = new SkillSystem(gameState, gameBridge.dataManager);
        
        await skillSystem.initializeSystem();
        
        // å»ºç«‹ç³»çµ±ä»£ç†
        setupSystemProxies();
        
        // æ›´æ–°ç³»çµ±ç‹€æ…‹é¡¯ç¤º
        updateSystemStatusDisplay();
        
        console.log('âœ… æ¥­å‹™ç³»çµ±åˆå§‹åŒ–å®Œæˆ');
        updateDisplay();
        
    } catch (error) {
        console.error('âŒ éŠæˆ²åˆå§‹åŒ–å¤±æ•—:', error);
        console.log('ğŸ”„ ä½¿ç”¨åŸå§‹ç³»çµ±æ¨¡å¼');
        updateDisplay();
    }
}

// å»ºç«‹ç³»çµ±ä»£ç†
function setupSystemProxies() {
    // ä»£ç†ç”Ÿæˆç”³è«‹è€…å‡½æ•¸
    window.originalGenerateApplicants = window.generateApplicants || function() {
        return [];
    };
    
    window.generateApplicants = function() {
        if (tenantSystem) {
            const applicants = tenantSystem.generateApplicants();
            gameState.applicants = applicants;
            return applicants;
        } else {
            return window.originalGenerateApplicants();
        }
    };

    // ä»£ç†é›‡ç”¨ç§Ÿå®¢å‡½æ•¸
    window.originalHireTenant = window.hireTenant || function() {
        return false;
    };
    
    window.hireTenant = function(applicantId) {
        if (tenantSystem) {
            const applicant = gameState.applicants.find(a => a.id === applicantId);
            if (applicant) {
                const success = tenantSystem.hireTenant(applicant);
                if (success) {
                    gameState.applicants = gameState.applicants.filter(a => a.id !== applicantId);
                }
                closeModal();
                updateDisplay();
                return success;
            }
            return false;
        } else {
            return window.originalHireTenant(applicantId);
        }
    };

    // ä»£ç†æŠ€èƒ½ä½¿ç”¨å‡½æ•¸
    window.originalUseSkill = window.useSkill || function() {
        return { success: false };
    };
    
    window.useSkill = async function(tenantName, skillId) {
        if (skillSystem && skillSystem.initialized) {
            return await skillSystem.executeSkill(tenantName, skillId);
        } else {
            return window.originalUseSkill(tenantName, skillId);
        }
    };
}

// æ›´æ–°ç³»çµ±ç‹€æ…‹é¡¯ç¤º
function updateSystemStatusDisplay() {
    const tenantStatusEl = document.getElementById('tenantSystemStatus');
    const tenantTextEl = document.getElementById('tenantSystemText');
    const skillStatusEl = document.getElementById('skillSystemStatus');
    const skillTextEl = document.getElementById('skillSystemText');
    const integrationStatusEl = document.getElementById('integrationStatus');
    const integrationTextEl = document.getElementById('integrationText');

    if (tenantSystem) {
        tenantStatusEl.className = 'status-indicator ready';
        tenantTextEl.textContent = 'âœ… å°±ç·’';
    } else {
        tenantStatusEl.className = 'status-indicator error';
        tenantTextEl.textContent = 'âŒ å¤±æ•—';
    }

    if (skillSystem && skillSystem.initialized) {
        skillStatusEl.className = 'status-indicator ready';
        skillTextEl.textContent = 'âœ… å°±ç·’';
    } else {
        skillStatusEl.className = 'status-indicator error';
        skillTextEl.textContent = 'âŒ å¤±æ•—';
    }

    if (tenantSystem && skillSystem && skillSystem.initialized) {
        integrationStatusEl.className = 'status-indicator ready';
        integrationTextEl.textContent = 'âœ… å®Œæˆ';
    } else {
        integrationStatusEl.className = 'status-indicator loading';
        integrationTextEl.textContent = 'â³ è™•ç†ä¸­';
    }

    // æ›´æ–°åŸºç¤ç³»çµ±ç‹€æ…‹
    const dataSystemEl = document.getElementById('dataSystem');
    const ruleEngineEl = document.getElementById('ruleEngine');

    if (dataSystemEl) {
        dataSystemEl.textContent = gameBridge && gameBridge.systemStatus.dataSystemReady ? 'âœ… å·²è¼‰å…¥' : 'âŒ ä½¿ç”¨é è¨­';
    }
    
    if (ruleEngineEl) {
        ruleEngineEl.textContent = gameBridge && gameBridge.ruleEngine ? 'âœ… å°±ç·’' : 'âŒ ä¸å¯ç”¨';
    }
}

// ==================== éŠæˆ²æ ¸å¿ƒåŠŸèƒ½ ====================

function addLog(message, type = "") {
    const log = document.getElementById("gameLog");
    const entry = document.createElement("div");
    entry.className = `log-entry ${type}`;
    entry.textContent = `ç¬¬${gameState.day}å¤©: ${message}`;
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
}

function getDefenseStatusText(defense) {
    if (defense <= 0) return `è„†å¼±(${defense})`;
    if (defense <= 2) return `åŸºæœ¬(${defense})`;
    if (defense <= 5) return `ç©©å›º(${defense})`;
    if (defense <= 8) return `å …å›º(${defense})`;
    if (defense <= 12) return `è¦å¡(${defense})`;
    return `éŠ…ç‰†éµå£(${defense})`;
}

function getHungerStatusText(hunger) {
    if (hunger <= 0) return `é£½è¶³(${hunger})`;
    if (hunger <= 1) return `å¾®é¤“(${hunger})`;
    if (hunger <= 2) return `æœ‰é»é¤“(${hunger})`;
    if (hunger <= 3) return `é£¢é¤“(${hunger})`;
    if (hunger <= 4) return `å¾ˆé¤“(${hunger})`;
    if (hunger <= 6) return `æ¥µåº¦é£¢é¤“(${hunger})`;
    return `ç€•è‡¨é¤“æ­»(${hunger})`;
}

function updateDisplay() {
    document.getElementById("day").textContent = gameState.day;
    document.getElementById("time").textContent = gameState.time === "day" ? "ç™½å¤©" : "å¤œæ™š";
    document.getElementById("cash").textContent = gameState.resources.cash;
    document.getElementById("buildingDefenseText").textContent = getDefenseStatusText(gameState.buildingDefense);
    document.getElementById("landlordHungerText").textContent = getHungerStatusText(gameState.landlordHunger);
    document.getElementById("scavengeCount").textContent = gameState.scavengeUsed;

    Object.keys(gameState.resources).forEach((resource) => {
        const element = document.getElementById(resource);
        if (element) {
            element.textContent = gameState.resources[resource];
        }
    });

    gameState.rooms.forEach((room) => {
        const roomElement = document.getElementById(`room${room.id}`);
        const infoElement = document.getElementById(`room${room.id}-info`);

        roomElement.className = "room";

        if (room.tenant) {
            roomElement.classList.add("occupied");
            if (room.tenant.infected) {
                roomElement.classList.add("infected");
            }

            const satisfaction = gameState.tenantSatisfaction[room.tenant.name] || 50;
            const satisfactionText = satisfaction >= 70 ? "ğŸ˜Š" : satisfaction >= 40 ? "ğŸ˜" : "ğŸ˜";

            infoElement.innerHTML = `${room.tenant.name}<br><small>${room.tenant.skill}</small><br><small>æ»¿æ„åº¦: ${satisfaction} ${satisfactionText}</small>`;
        } else {
            infoElement.textContent = "ç©ºæˆ¿";
        }

        if (room.needsRepair) {
            roomElement.classList.add("needs-repair");
            infoElement.innerHTML += '<br><small style="color:#ff6666">éœ€è¦ç¶­ä¿®</small>';
        }

        if (room.reinforced) {
            roomElement.classList.add("reinforced");
            infoElement.innerHTML += '<br><small style="color:#66ccff">å·²åŠ å›º</small>';
        }
    });

    updateTenantList();
}

function updateTenantList() {
    const tenantList = document.getElementById("tenantList");
    const tenants = gameState.rooms
        .filter((room) => room.tenant)
        .map((room) => room.tenant);

    if (tenants.length === 0) {
        tenantList.innerHTML = '<div class="tenant-item">æš«ç„¡ç§Ÿå®¢</div>';
    } else {
        tenantList.innerHTML = tenants
            .map((tenant) => {
                let statusText = "";
                if (tenant.infected) {
                    statusText = '<br><small style="color:#ff6666">å·²æ„ŸæŸ“ï¼</small>';
                } else if (tenant.onMission) {
                    statusText = '<br><small style="color:#ffaa66">åŸ·è¡Œä»»å‹™ä¸­</small>';
                }

                const resourceStatus = tenant.personalResources
                    ? `<br><small style="color:#cccccc">å€‹äºº: $${tenant.personalResources.cash || 0} é£Ÿç‰©${tenant.personalResources.food || 0}</small>`
                    : "";

                const satisfaction = gameState.tenantSatisfaction[tenant.name] || 50;

                return `<div class="tenant-item ${tenant.infected ? "infected" : ""} ${tenant.typeId}">
                    ${tenant.name} (${tenant.typeName})<br>
                    <small>æˆ¿ç§Ÿ: ${tenant.rent} | ${tenant.skill}</small>
                    ${resourceStatus}
                    <small>æ»¿æ„åº¦: ${satisfaction}%</small>
                    ${statusText}
                </div>`;
            })
            .join("");
    }
}

// åŸºæœ¬éŠæˆ²åŠŸèƒ½ - ç°¡åŒ–ç‰ˆæœ¬ï¼Œä¿æŒæ ¸å¿ƒåŠŸèƒ½
function collectRent() {
    if (gameState.rentCollected) {
        alert("ä»Šå¤©å·²ç¶“æ”¶éæˆ¿ç§Ÿäº†ï¼");
        return;
    }

    let totalRent = 0;
    gameState.rooms.forEach((room) => {
        if (room.tenant && !room.tenant.infected) {
            totalRent += room.tenant.rent;
        }
    });

    gameState.resources.cash += totalRent;
    gameState.rentCollected = true;
    
    if (totalRent > 0) {
        addLog(`æ”¶å–æˆ¿ç§Ÿ $${totalRent}`, "rent");
    } else {
        addLog("ä»Šæ—¥æ²’æœ‰æˆ¿ç§Ÿæ”¶å…¥", "event");
    }
    
    updateDisplay();
}

function showVisitors() {
    // ç”Ÿæˆè¨ªå®¢
    generateApplicants();
    
    const modal = document.getElementById("visitorModal");
    const list = document.getElementById("visitorList");

    list.innerHTML = gameState.applicants
        .map((applicant) => {
            const infectionStatus = applicant.revealedInfection
                ? '<br><span style="color:#ff6666; font-weight:bold;">âš  å·²æª¢æ¸¬å‡ºæ„ŸæŸ“ï¼</span>'
                : "";

            return `<div class="applicant ${applicant.revealedInfection ? "infected" : ""}">
                        <strong>${applicant.name}</strong> - ${applicant.typeName}<br>
                        <small>${applicant.description || 'å°‹æ‰¾ä½æ‰€çš„å€–å­˜è€…'}</small><br>
                        <small style="color: #aaa;">å¤–è§€: ${applicant.appearance}</small><br>
                        æˆ¿ç§Ÿ: ${applicant.rent}/å¤©${infectionStatus}<br>
                        <button class="btn ${applicant.revealedInfection ? "danger" : ""}" 
                                onclick="hireTenant('${applicant.id}')" 
                                ${applicant.revealedInfection ? 'title="é›‡ç”¨æ„ŸæŸ“è€…é¢¨éšªå¾ˆé«˜ï¼"' : ""}>
                          é›‡ç”¨${applicant.revealedInfection ? " (å±éšª)" : ""}
                        </button>
                      </div>`;
        })
        .join("");

    modal.style.display = "block";
}

function showScavengeMenu() {
    alert("æ´¾é£åŠŸèƒ½æ­£åœ¨é‡æ§‹ä¸­ï¼Œè«‹ç¨å€™...");
}

function harvestYard() {
    if (gameState.harvestUsed) {
        alert("ä»Šå¤©å·²ç¶“æ¡é›†éé™¢å­äº†ï¼");
        return;
    }

    const baseAmount = 2;
    gameState.resources.food += baseAmount;
    gameState.harvestUsed = true;
    
    addLog(`é™¢å­æ¡é›†ç²å¾— ${baseAmount} é£Ÿç‰©`, "rent");
    updateDisplay();
}

function showSkillMenu() {
    if (!skillSystem || !skillSystem.initialized) {
        alert("æŠ€èƒ½ç³»çµ±æ­£åœ¨è¼‰å…¥ä¸­ï¼Œè«‹ç¨å€™...");
        return;
    }

    const modal = document.getElementById("skillModal");
    const skillList = document.getElementById("skillList");

    const skillsByTenant = [];

    gameState.rooms.forEach((room) => {
        if (room.tenant && !room.tenant.infected) {
            const tenant = room.tenant;
            const tenantSkills = skillSystem.getAvailableSkills(tenant.name);

            if (tenantSkills.length > 0) {
                skillsByTenant.push({
                    tenant: tenant,
                    skills: tenantSkills
                });
            }
        }
    });

    if (skillsByTenant.length === 0) {
        skillList.innerHTML = "<p>ç›®å‰æ²’æœ‰å¯ç”¨çš„æŠ€èƒ½</p>";
    } else {
        skillList.innerHTML = skillsByTenant
            .map((tenantData) => {
                const tenant = tenantData.tenant;
                const skills = tenantData.skills;

                return `
                    <div class="tenant-skill-group">
                      <h4 style="color: #66ccff; margin: 15px 0 10px 0;">
                        ${tenant.name} (${tenant.typeName}) - æˆ¿é–“${getRoomIdByTenant(tenant)}
                      </h4>
                      <div style="font-size: 11px; color: #aaa; margin-bottom: 10px;">
                        å€‹äººç¾é‡‘: $${tenant.personalResources?.cash || 0}
                      </div>
                      ${skills
                        .map(
                          (skill) => `
                        <div class="skill-actions">
                          <h5 style="margin: 5px 0; color: #ffcc66;">${skill.name}</h5>
                          <p style="margin: 5px 0; font-size: 12px;">${skill.description}</p>
                          <button class="btn success" onclick="useSkillFromMenu('${tenant.name}', '${skill.id}')">
                            ä½¿ç”¨æŠ€èƒ½
                          </button>
                        </div>
                      `
                        )
                        .join("")}
                    </div>
                  `;
            })
            .join("");
    }

    modal.style.display = "block";
}

async function useSkillFromMenu(tenantName, skillId) {
    const result = await useSkill(tenantName, skillId);
    
    if (result.success) {
        addLog(`æŠ€èƒ½ ${result.skillName} åŸ·è¡ŒæˆåŠŸ`, 'skill');
    } else {
        addLog(`æŠ€èƒ½åŸ·è¡Œå¤±æ•—: ${result.reason}`, 'danger');
    }
    
    closeModal();
    updateDisplay();
}

function getRoomIdByTenant(tenant) {
    const room = gameState.rooms.find((r) => r.tenant === tenant);
    return room ? room.id : "æœªçŸ¥";
}

function selectRoom(roomId) {
    const room = gameState.rooms.find((r) => r.id === roomId);
    if (room.tenant) {
        alert(`æˆ¿é–“ ${roomId} - ${room.tenant.name} (${room.tenant.typeName})`);
    } else {
        alert(`æˆ¿é–“ ${roomId} - ç©ºæˆ¿`);
    }
}

function nextDay() {
    // åŸºæœ¬çš„æ—¥æœŸæ¨é€²é‚è¼¯
    gameState.day++;
    gameState.harvestUsed = false;
    gameState.scavengeUsed = 0;
    gameState.rentCollected = false;
    
    // è™•ç†ç§Ÿå®¢æ—¥å¸¸æ›´æ–°
    if (tenantSystem) {
        tenantSystem.updateDailyTenantStates();
    }

    // æˆ¿æ±æ¶ˆè²»é£Ÿç‰©
    if (gameState.resources.food >= 2) {
        gameState.resources.food -= 2;
        gameState.landlordHunger = Math.max(0, gameState.landlordHunger - 1);
        addLog("æˆ¿æ±æ¶ˆè€—äº† 2 é£Ÿç‰©", "event");
    } else {
        gameState.landlordHunger += 1;
        addLog("æˆ¿æ±æ²’æœ‰è¶³å¤ é£Ÿç‰©ï¼", "danger");
    }
    
    // ç‡ƒæ–™æ¶ˆè²»
    if (gameState.resources.fuel > 0) {
        gameState.resources.fuel -= 1;
        addLog("æ¶ˆè€—äº† 1 ç‡ƒæ–™", "event");
    }
    
    addLog("æ–°çš„ä¸€å¤©é–‹å§‹äº†", "event");
    updateDisplay();
}

function closeModal() {
    document.querySelectorAll(".modal").forEach((modal) => {
        modal.style.display = "none";
    });
}

// æ–°å¢ç³»çµ±è³‡è¨ŠåŠŸèƒ½
function showSystemInfo() {
    if (!gameBridge) {
        alert("ç³»çµ±æ©‹æ¥å™¨æœªåˆå§‹åŒ–");
        return;
    }

    const info = gameBridge.getSystemInfo();
    const modal = document.getElementById("systemInfoModal");
    const content = document.getElementById("systemInfoContent");
    
    content.innerHTML = `
        <h4>ç³»çµ±æ¶æ§‹è³‡è¨Š</h4>
        <p><strong>ç‰ˆæœ¬:</strong> ${info.version}</p>
        <p><strong>æ¨¡å¼:</strong> ${info.mode}</p>
        
        <h4>DataManager</h4>
        <p><strong>ç‹€æ…‹:</strong> ${info.dataManager.available ? 'âœ… å¯ç”¨' : 'âŒ ä¸å¯ç”¨'}</p>
        <p><strong>å·²è¼‰å…¥è³‡æ–™:</strong> ${info.dataManager.loadedTypes.join(', ') || 'ç„¡'}</p>
        
        <h4>RuleEngine</h4>
        <p><strong>ç‹€æ…‹:</strong> ${info.ruleEngine.available ? 'âœ… å¯ç”¨' : 'âŒ ä¸å¯ç”¨'}</p>
        <p><strong>è¦å‰‡æ•¸é‡:</strong> ${info.ruleEngine.ruleCount}</p>
                
        <h4>æ¥­å‹™ç³»çµ±</h4>
        <p><strong>TenantSystem:</strong> ${tenantSystem ? 'âœ… å¯ç”¨' : 'âŒ ä¸å¯ç”¨'}</p>
        <p><strong>SkillSystem:</strong> ${skillSystem && skillSystem.initialized ? 'âœ… å¯ç”¨' : 'âŒ ä¸å¯ç”¨'}</p>

        <h4>éŠæˆ²ç‹€æ…‹</h4>
        <p><strong>ç•¶å‰å¤©æ•¸:</strong> ${gameState.day}</p>
        <p><strong>ç¾é‡‘:</strong> $${gameState.resources.cash}</p>
        <p><strong>ç§Ÿå®¢æ•¸é‡:</strong> ${gameState.rooms.filter(r => r.tenant).length}</p>
    `;
    
    modal.style.display = "block";
}

// ==================== éŠæˆ²å•Ÿå‹• ====================
// é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–éŠæˆ²
document.addEventListener('DOMContentLoaded', () => {
    console.log('ğŸ® æœ«æ—¥æˆ¿æ±æ¨¡æ“¬å™¨ v1.1 - é‡æ§‹ç‰ˆå•Ÿå‹•');
    initializeGame();
    
    // åˆå§‹åŒ–éŠæˆ²è¨˜éŒ„
    addLog("æ­¡è¿ä¾†åˆ°æœ«æ—¥æˆ¿æ±æ¨¡æ“¬å™¨é‡æ§‹ç‰ˆï¼", "event");
    addLog("ç•¶å‰ä½¿ç”¨å…ˆé€²çš„æ··åˆæ¶æ§‹ç³»çµ±", "event");
    addLog("é»æ“Šå³ä¸Šè§’ç³»çµ±ç‹€æ…‹æŸ¥çœ‹è©³ç´°è³‡è¨Š", "event");
});
</script>
</body>
</html>